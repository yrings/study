### 进程和线程的区别

* #### 进程

  每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。进程实体（进程映像）：程序段、数据段、PCB(进程控制块)三部分组成了进程实体（进程映像）

  三种状态：

  1. **就绪状态**在等待获取CPU
  2. **执行状态**某进程占用CPU并在CPU上执行程序
  3. **阻塞状态**也称为等待状态或封锁状态。如：请求I/O。（多个等待队列） 

* #### 线程

  与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

**根本区别：**进程是操作系统资源分配的基本单位。线程是任务调度和执行的基本单位。

**资源开销：**每个进程都有自己的独立代码和数据空间，在切换进程时会有很大的开销。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间的切换开销较小。

**包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

### 进程拥有的资源

地址空间、全局变量、子进程、信号量

### 什么是堆和栈

**栈**：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

**堆**： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由系统回收，分配方式倒是类似于链表。

**堆栈缓存方式区别**：
栈使用的是一级缓存， 通常都是被调用时处于存储空间中，调用完毕立即释放；
堆是存放在二级缓存中，调用这些对象的速度要相对来得低一些。
堆栈数据结构区别：
堆：堆可以被看成是一棵树，如：堆排序；

**栈**：一种先进后出的数据结构。

**栈和堆的区别**：

**管理方式不同**，栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

**分配方式不同**，堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由`alloca()`函数分配，但是栈的动态分配和堆是[不同的](https://so.csdn.net/so/search?q=不同的&spm=1001.2101.3001.7020)，它的动态分配是由操作系统进行释放，无需我们手工实现。

**空间大小不同**，栈的大小要远远小于堆的大小。

**生长方向不同**，堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低

**分配效率不同**，栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

### 死锁

**什么是死锁？**

**答：** 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是**两个或多个进程无限期的阻塞、相互等待的一种状态**。

死锁条件：

死锁发生通常需要满足以下四个条件：

1. **互斥条件（Mutual Exclusion）**：
   - 至少有一个资源必须是被排他使用的，即一次只能被一个进程或线程访问。
2. **请求与保持条件（Hold and Wait）**：
   - 进程已经持有至少一个资源，并且在等待获取其他进程持有的资源。
3. **不可剥夺条件（No Preemption）**：
   - 已经分配给进程的资源不能被强制性地剥夺，只能由持有它的进程自愿释放。
4. **循环等待条件（Circular Wait）**：
   - 多个进程形成一个循环等待资源的环路，每个进程都在等待下一个进程所持有的资源。

避免死锁的策略：

1. **破坏互斥条件**：
   - 尽量减少资源的互斥使用，或者使用可共享的资源代替排他资源。
2. **破坏请求与保持条件**：
   - 要求进程在开始执行前一次性获取所有需要的资源，而不是逐个获取。
3. **破坏不可剥夺条件**：
   - 允许操作系统剥夺一部分资源，以满足其他进程的资源请求。
4. **破坏循环等待条件**：
   - 通过对资源进行排序，要求进程按照固定顺序请求资源，从而避免循环等待。
5. **资源分配图**：
   - 使用资源分配图检测死锁，并根据检测结果采取相应的措施。
6. **超时机制**：
   - 对资源的申请设置超时机制，在一定时间内未能获取到资源，则放弃当前申请，释放已占有的资源，以避免死锁的发生。
7. **死锁检测与恢复**：
   - 定期检测系统中是否存在死锁，如果存在则采取相应的恢复措施，如资源剥夺或进程终止等。

### 输入URL会经历的过程

从浏览器输入一个URL到页面出现，经历以下过程：

1. **DNS解析**：查找浏览器缓存或进行域名解析，获取IP地址。
2. **TCP连接**：浏览器向服务器发送TCP连接，进行三次握手。
3. **浏览器发送HTTP请求**：请求服务器获取资源。
4. **服务器处理请求**：解析请求，生成响应头和内容。
5. **释放连接**：关闭TCP连接。
6. **浏览器解析渲染页面**：构建DOM树，渲染页面

### 域名解析过程

1. 首先回到浏览器缓存中查找是否有这个url解析过的IP地址。如果没有就进入下一步
2. 会到操作系统缓存中查看，这个缓存可以通过hosts文件设置解析缓存。
3. 前两个过程无法解析时，就要用到我们网络配置中的"**DNS服务器地址**"了。操作系统会把这个域名发送给这个本地DNS服务器。每个完整的内网通常都会配置本地DNS服务器，例如用户是在学校或工作单位接入互联网，那么用户的本地DNS服务器肯定在学校或工作单位里面。它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，后续的DNS迭代和递归也是由本地DNS服务器负责。
4. 如果本地DNS服务器仍然没有命中，就直接到**根DNS服务器**请求解析
5. 根DNS服务器返回给本地DNS域名服务器一个**顶级DNS服务器**地址，它是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。
6.  本地DNS服务器再向上一步获得的顶级DNS服务器发送解析请求。
7. 接受请求的顶级DNS服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server服务器就是我要访问的网站域名提供商的服务器，其实该域名的解析任务就是由域名提供商的服务器来完成。   比如我要访问www.baidu.com，而这个域名是从A公司注册获得的，那么A公司上的服务器就会有www.baidu.com的相关信息。
8. Name Server服务器会查询存储的域名和IP的映射关系表，再把查询出来的域名和IP地址等等信息，连同一个TTL值返回给本地DNS服务器。

### TCP三握而不是二握

* 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 **三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤**
* 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

## http和https的区别

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



##  SSL是什么意思

> SSL(Secure Sockets Layer 安全套接层)及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。如今被广泛使用，如网页，电子邮件，互联网传真，即时消息和语音在IP电话（VoIP）。其中网站是通过使用TLS来保护WEB浏览器与服务器之间的通信安全。

**SSL (Secure Socket Layer)**

为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。

**SSL协议可分为三层：**

SSL握手协议(SSL Handshake Protocol)：握手协议是客户机和服务器用SSL连接通信时使用的第一个子协议，握手协议包括客户机与服务器之间的一系列消息。SSL中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和MAC算法以及保密密钥，用来保护在SSL记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。

SSL记录协议(SSL Record protocol)：记录协议在客户机和服务器握手成功后使用，即客户机和服务器鉴别对方和确定安全信息交换使用的算法后，进入SSL记录协议，记录协议向SSL连接提供两个服务：

（1）保密性：使用握手协议定义的秘密密钥实现

（2）完整性：握手协议定义了MAC，用于保证消息完整性

SSL警报协议(SSL Handshake Protocol)：客户机和服务器发现错误时，向对方发送一个警报消息。如果是致命错误，则算法立即关闭SSL连接，双方还会先删除相关的会话号，秘密和密钥。每个警报消息共2个字节，第1个字节表示错误类型，如果是警报，则值为1，如果是致命错误，则值为2；第2个字节制定实际错误类型。

**SSL协议提供的服务主要有：**

1)认证用户和服务器，确保数据发送到正确的客户机和服务器;

2)加密数据以防止数据中途被窃取;

3)维护数据的完整性，确保数据在传输过程中不被改变。

**SSL协议的工作流程：**

1：客户端的浏览器向服务器传送客户端 SSL 协议的版本号，加密算法的种类，产生的**随机数1**，以及其他服务器和客户端之间通讯所需要的各种信息。

2：服务器向客户端传送 SSL 协议的版本号，加密算法的种类，**随机数2**以及其他相关信息，**同时服务器还将向客户端传送自己的证书（公钥）**。

3：**客户利用服务器传过来的信息验证服务器的合法性**，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。

4：**用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。**

5：如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。

6：如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。

7：服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。

8：客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。

9：服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。

10：SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。



HTTPS 中的 S代表的是SSL/TLS，SSL是TLS的前身，现在大多数浏览器只支持TLS了。

**对称加密：**

通信双方都用同样的解密规则来对密码进行加解密。

**非对称加密：**

服务端有一个私钥和一个公钥。公钥让客户端知道。

加密规则是：

数据经过公钥加密后，只能被私钥解密。

数据经过私钥加密后，只能被公钥解密

> SSL证书

SSL证书是由特定机构（大家都认可的证书机构）发送给网站的，里面记录了服务器的公钥、所属域名等信息，在服务器安装SSL证书，就可以通过HTTPS来访问服务器了。（HTTPS的默认端口443）

HTTPS请求过程：

![](F:\study\网络\image\屏幕截图 2024-02-17 235521.png)

**由于会话密钥没有被非加密传输，是非常安全的。故得到会话密钥后，通信双方就只使用对称加密来进行数据传输，减小开销**

用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。

### 没有https的缺点：

1. 无法进行身份验证，无法保证访问的页面是否为官方地址。 
2. 不能保证数据的完整性，可能会被更改。
3. 保证不了数据的机密性，容易泄密。

### CA数字证书

> 服务器发送的用于用户加密的密钥可能会被黑客截胡篡改，这时就需要第三方来保证密钥的可靠性，这时就出现了CA数字证书

网站需要先把用来给你加密的公钥放在大家都信任的第三方CA那里，第三方CA就会**根据这把公钥以及其它信息生成了“数字证书”。**

> 这时又出现问题了，我们如何相信“数字证书”就是由信任的CA颁发的呢？
>
> “数字证书”上有CA的数字签名就可以了。当CA收到服务器的信息以及公钥以后，会对这些信息进行哈希运算（SHA256），然后获得一串较短的字符串（便于传输和加密解密）；**这时CA会生成一对私钥和公钥，然后用私钥再对这个字符串进行加密，这就生成数字签名**。

客户端收到数字证书后，会用CA公钥来解密数字签名，然后对证书上的内容同样进行哈希运算（SHA256），然后比较数字签名和证书上的信息是否一致。（**只有拥有私钥才能够同时修改两者**）。

> 问题又又又出现了，客户端如何拿到CA公钥的呢？而服务器又怎么保证拿到的证书是安全可靠的呢？
>
> CA证书同样也需要一个证书来证明自己的可靠性，然后把这个CA公钥放入到证书里面，即根CA。然后根CA的证书由自己加密，然后在用户操作系统和浏览器里面预先安装根CA的证书（有公钥）。



## TCP拥塞控制

> 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变差，这种情况就叫做网络拥塞。
>
> 若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。路由器缓存溢出，拥塞会导致丢包。

![](F:\study\网络\image\屏幕截图 2024-01-13 120149.png)



* ### TCP四种拥塞控制算法

  1. 慢开始
  2. 拥塞避免
  3. 快重传
  4. 快恢复

* ### 拥塞控制过程

  > 假定：
  >
  > 1. 数据是单方向传送的，而另一个方向只传送确认
  > 2. 接收方总是有足够大的缓存空间，因而发送发发送窗口的大小由网络的拥塞程度来决定
  > 3. 以TCP报文段的个数为讨论问题的单位，而不是以字节为单位

  * #### 慢启动

  ![](F:\study\网络\image\屏幕截图 2024-01-13 121346.png)

  慢启动会**指数**地增加拥塞窗口的大小，直到超过或等于`ssthreash`，就用拥塞避免算法。

  慢启动，累积确认，每收到一个确认报文就会增加一，所以是指数增长。

  当拥塞窗口大于慢开始门限（ssthresh），就会触发拥塞避免算法，拥塞窗口cwnd只能线性加一线性增加拥塞窗口大小。

  （**快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段**。）

  当收到3个重复ACK（即重传），就会发生块重传和快恢复机制。

  * #### 拥塞避免

    ![](F:\study\网络\image\屏幕截图 2024-01-13 122538.png)

    拥塞避免算法会**线性**增加拥塞窗口大小，直到发生重传（收到三次重复确认），即快重传，之后就会发生快重传。**将`ssthreash`设置为发生拥塞时的`cwnd`的一半**

    快重传

    发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传时再重传。

  * 快恢复

    * 当发送端收到第三个重复确认的报文时，会更新ssthresh的值，然后立即重传丢失的报文段，并且设置：cwnd = ssthresh+3*SMSS，进入拥塞避免阶段。
    * 当收到一个重复确认的报文时，设置cwnd = cwnd +SMSS。此时发送端可以发送新的TCP报文（如果新的cwnd允许）
    * 当收到新数据的确认时，设置cwnd=ssthresh。进入拥塞避免阶段。

> 新的TCP Reno 版本在快重传之后采用快回复算法而不是采用慢开始

#### 拥塞控制窗口和流量控制窗口的区别

> 两者作用上的区别:
>
> **流量控制是为了解决发送方和接收方速度不同而导致的数据丢失问题**,当发送方发送的太快,接收方来不及接受就会导致数据丢失,流量控制用滑动窗口的形式解决问题
>
> **拥塞控制是为了解决过多的数据注入到网络,导致网络奔溃,超过负荷**.当发送方发送数据大量的数据会注入到网络,如果没有限制,网络就会超负荷变卡,拥塞控制的用的是拥塞窗口解决的问题的

## CSRF（跨站请求伪造漏洞）

> **CSRF(Cross-Site Request Forgery)**，跟XSS漏洞攻击一样，存在巨大的危害性
>
> 你可以这么来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等

黑客会伪造一个网站，当你进入网站时，就会触发请求，如果这个请求资源路径没有CSRF防御，并且你的登陆cookie并没有失效，就能对你的用户进行非法操作。

**防御手段：**

1. 加入验证码，这时最有效简单的请求。
2. 验证 Referer，即HTTP协议带的参数，即请求来源，服务端可以验证请求来源来防御；但是有些浏览器可以修改这个属性，所以这个方法并不是最好的
3. Anti CSRF Token，每次访问网站时，服务端都会发送并记录在服务端一个token来验证请求中是否带上这个防御token，这也可以说是另一种验证码。
4. 加入自定义的 Header与上面的方法类似



## 64位和32位系统的区别

一、32位操作系统最大支持4GB内存大小的电脑
我们都知道，计算机只能识别二进制数字。而位（Bit）是计算机的最小存储单位，存放0或1。**32位操作系统是指系统的最大寻址能力为32位**，那么对应的地址空间就为：
2 32 ÷ 1024 ÷ 1024 ÷ 1024 = 4 ( G B ) 2^{32}\div1024\div1024\div1024=4(GB)
2 
32
 ÷1024÷1024÷1024=4(GB)

因此，32位操作系统最大寻址空间仅为4GB，最大只能支持4GB的内存大小。
当电脑内存超过4GB之后，比如现在最常见的8GB内存大小，系统无法对超过4GB以外的内存进行操作。

二、64位操作系统支持所有的电脑
同理，32位操作系统是指系统的最大寻址能力为64位，那么对应的地址空间就为：
2 64 ÷ 1024 ÷ 1024 ÷ 1024 ≈ 1.7 × 1 0 10 ( G B ) 2^{64}\div1024\div1024\div1024\approx1.7\times10^{10}(GB)
2 
64
 ÷1024÷1024÷1024≈1.7×10 
10
 (GB)

可以看出，64位操作系统可支持的内存是非常大的，甚至远远大于现有电脑的磁盘存储空间，因此64位是可以适用于所有电脑的。但对于我们普通使用者来说，8G或16G内存的电脑就可以满足正常的学习、工作了。而且，内存并不是越大越好的，还要结合电脑的CPU、磁盘等硬件的性能进行选配，才能达到更好的效果。

## OSI的七层结构

> 开放系统互联（Open System Interconnection，OSI），是一种概念模型。
>
> HTTP协议在应用层，IP协议在网络层

![](F:/study/java/interview/image/屏幕截图 2024-01-13 115336.png)



![](F:/study/java/interview/image/屏幕截图 2024-01-13 115517.png)

#### 网络层和传输层负责的内容有什么区别？

* #### 网络层

  计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。

  该层的主要任务就是：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。

* #### 传输层

  当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。

  简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。

## 事务

一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 隔离性级别

* **读未提交（Read UnCommitted/RU）**

  一个事务可以读取到另一个事务未提交的数据。

  **脏读**：如果另一个事务发起了回滚，会导致数据一致性问题。

* **读已提交（Read Committed/RC）**

  一个事务提交之后，它做的变更才会被其它事务看到

  **不可重复读**：同一事务先后读取同一个数据，在这期间数据发送了变化，两次读取的结果不一致。

* **可重复读（Repeatable Read）**（MySQL的InnoDB默认的隔离级别）

  一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

  **幻读**：同一事务按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为前者是数据变了，后者是数据的行数变了。

* **可串行化**



## zset的底层数据结构（跳表）

**（1）什么是skipList**

​	skipList，跳跃列表，简称跳表，是一种**随机化**的数据结构，基于并联的链表，实现简单，查找效率较高。简单来说跳表也是链表的一种，不过在查找元素时，有较高的效率。

**（2）skipList原理**

对于一个有序链表，如果要查找某个数据，需要从头开始查找，直到查到对应的元素，这样的查找效率较低，相同的，要插入数据时效率也不够高。

**这时为了提高查询效率，在偶数节点上增加一个指针，让其指向下一个偶数节点。**

![](F:\study\redis\image\屏幕截图 2023-09-20 105357.png)

这样所有偶数节点又构成了一个新的链表，**即高层链表**。

此时想要查找或插入某个元素时，先在高层链表查找元素，找到目标节点的前一个较大节点，然后再回到原链表中查找。

如果还想要提高查找效率，可以再构建高层链表。

**但是此时存在的问题是：由于固定序号的元素拥有固定层级，所以在元素增删的情况下，会导致整体元素层级大调整，然后重新进行层级划分，会大大降低系统性能。**

为了优化算法，避免前面的问题，实际上skipList采用了**随机分配层级方式**。

即在确定了总层级后，每添加一个新的元素时，会自动为其随机分配的一个层级。这种随机性就解决了节点序号和层级间的固定关系的问题。

> skipList 指的就是除了最下面第 1 层链表之外，它会产生若干层稀疏的链表，这些链表 里面的指针跳过了一些节点，并且越高层级的链表跳过的节点越多。在查找数据的时先在高 层级链表中进行查找，然后逐层降低，最终可能会降到第 1 层链表来精确地确定数据位置。 在这个过程中由于跳过了一些节点，从而加快了查找速度。



## 进程线程上下文

进程和线程上下文切换的区别在于：

* 进程是资源分配的基本单位，线程是进程中的执行流程。

- 进程拥有自己的地址空间和资源，线程共享进程的资源。
- 进程切换需要保存和加载进程的相关信息、状态变更、队列操作、调度算法等，线程的上下文切换相比进程较小，只需要保存线程的相关寄存器和计数器等信息。
- 进程消耗更多资源，而线程消耗较少资源。
- 进程间通信需要更多时间，而线程间通信需要较少时间。



## redis基本数据类型

支持多种类型的数据结构

- 字符串 strings
- 散列 hashes
- 列表 lists
- 集合 sets
- 有序集合 sorted sets
- bitmaps
- hyperloglogs
- 地理空间 geospatial 索引半径查询

### GenHash算法



### 淘汰策略

maxmemory-policy

* volatile-lru：使用近似 LRU 算法移除，仅适用于设置了过期时间的 key。 

* allkeys-lru：使用近似 LRU 算法移除，可适用于所有类型的 key。 

* volatile-lfu：使用近似 LFU 算法移除，仅适用于设置了过期时间的 key。 

* allkeys-lfu：使用近似 LFU 算法移除，可适用于所有类型的 key。 

* volatile-random：随机移除一个 key，仅适用于设置了过期时间的 key。 

* allkeys-random：随机移除一个 key，可适用于所有类型的 key。 

* volatile-ttl：移除距离过期时间最近的 key。
* noeviction：不移除任何内容，只是在写操作时返回一个错误，默认值。

## MySQL索引失效

1、带有运算

2、使用函数

3、使用%XXX左模糊查询，因为mysql是最左原则，**使用XXX%右模糊查询是可以使用索引的**，但是左模糊违背了最左原则所以不行

4、使用范围运算，not in，in > ,<都不行

5、**查询的字段不是索引的最左字段，同样是因为最左原则**

6、字段类型不匹配，常见的隐式数据类型转换，mobile=1356不会走索引，会转换为字符串可以查询但是，mobile='1356'会走索引

7、or条件左边的是索引字段，右边的不是。也不会走索引，因为or是一个并集



## gin面试题

### Gin框架的特点

Gin框架是一个用Go语言编写的Web框架，它被设计为一个高性能、易用、高效的HTTP Web框架。Gin提供了一系列强大的功能，使得它非常适合于构建高效的Web应用和微服务。以下是Gin框架的一些主要特点和优点：

**高性能**：Gin框架的一个显著特点是它的高性能。它比其他Go语言的Web框架更快，因为它使用了定制的路由器，减少了内存分配，从而提高了性能。

**强大的路由能力**：Gin的路由功能强大且灵活，支持参数传递、路由分组等功能。

**易用性**：Gin提供了简洁的API，使得开发者可以快速地构建Web应用。它的路由定义简单明了，便于理解和使用。

**中间件支持**：Gin支持中间件，允许用户可以方便地在处理流程中加入自定义的处理逻辑，例如日志记录、用户鉴权、数据处理等。

**错误处理**：Gin提供了强大的错误处理功能，能够捕获并处理请求过程中发生的各种错误。

**扩展性**：Gin框架具有良好的扩展性，支持多种格式的请求和响应，包括JSON、XML等，并且可以很容易地集成其他Go语言的库或框架。

**社区支持**：由于其流行性和高效性，Gin拥有一个活跃的社区，提供了大量的资源和库，可以帮助开发者解决各种问题。

### 压缩前缀树

Trie，被称为前缀树或字典树，是一种有序树，其中的键通常是单词和字符串，所以又有人叫它单词查找树。

除根节点外，每一个节点只包含一个字符。

每个节点的所有子节点包含的字符都不相同。

优点：利用字符串公共前缀来减少查询时间，减少无谓的字符串比较

现在压缩 trie 树(Compressed Trie Tree)中的唯一子节点，就可以构建一颗 radix tree 基数树。

父节点下第一级子节点数小于 2 的都可以进行压缩，把子节点合并到父节点上

它是一颗多叉树，即每个节点分支数量可能为多个，根节点不包含字符串。

从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。

### 如何解决跨域问题？

Gin 框架处理跨域问题的常用方法是使用中间件来设置相应的 HTTP 头部。跨域资源共享（CORS）是一种安全机制，用于控制一个域下的资源被另一个域的脚本访问时的权限。在 Gin 中配置跨域，你可以通过编写一个自定义的中间件来实现。

下面是一个示例中间件，用于配置跨域问题的解决方案：
```go
func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }

        c.Next()
    }
}
```

在这个中间件中，我们设置了几个关键的 HTTP 头部，来允许跨域请求。特别是：

Access-Control-Allow-Origin: 这个头部指定了哪些域可以访问资源。这里设置为 * 表示允许所有域的访问。
Access-Control-Allow-Methods: 指定了允许的 HTTP 方法（如 GET, POST, DELETE 等）。
Access-Control-Allow-Headers: 指定了在跨域请求中可以使用的 HTTP 头部列表。
Access-Control-Allow-Credentials: 表示是否允许发送 cookies。



### 如何处理并发请求

在Gin框架中处理并发请求是基于Go语言本身的并发特性。Go语言的并发模型以协程（goroutines）为基础，这使得在Gin中处理多个并发请求变得相对简单且高效。以下是Gin处理并发请求的几个关键点：

1. **基于Goroutines**：每当Gin接收到一个新的HTTP请求时，它会为每个请求启动一个新的goroutine。这意味着每个请求都在自己的goroutine中独立运行，从而实现并发处理。
2. **无需额外配置**：由于Go语言和Gin框架的设计，开发者通常不需要进行特别的配置或编码来支持并发。Gin和Go的运行时系统自动处理请求的并发执行。
3. **同步和数据竞争**：虽然Gin帮助简化了并发处理，但在处理共享资源时，开发者仍需注意同步和数据竞争问题。例如，当多个请求需要访问同一个数据库或文件时，应该使用互斥锁（mutexes）或其他同步机制来防止数据竞争和一致性问题。
4. **性能优化**：Gin框架的高性能特性使得它在处理大量并发请求时表现出色。然而，根据应用的具体需求和部署环境，可能需要进行一些性能优化，比如优化数据库连接池、减少内存分配、使用高效的数据结构等。



# gRPC

> RPC关键在于
>
> 一是服务端使用反射对函数进行映射，当请求到来时，使用这个映射进行调用。
>
> 二是要自定义关系通讯格式。

gRPC是RPC的一种**流行实现**，许多组织采取gRPC作为首选RPC机制来连接**数据中心内**和**跨数据中心内**运行的大量微服务。

## gRPC流行的原因？

1. gRPC有蓬勃发展的开发者生态系统，支持多种语言的API。

   该生态系统中使用 protobuf（protocol buffers）作为**数据交换格式**。这个格式是一种与语言和平台无关的机制，用于编码结构化数据。但gRPC也支持JSON格式，但是protobuf一般都是首选。

   protobuf支持**强类型架构定义**——网络上的数据结构在原型文件中定义。它提供广泛的工具支持，将原始文件中的定义的架构转化为所有流行语言的数据访问类。也是在原型文件中确定指定参数和返回值来定义RPC方法。

   使用相同的工具利用proto文件来生成客户端和服务端代码，并使用这些生成的类来进行RPC调用。

   因为支持多种语言，客户端和服务器可以独立选择合适的编程语言。大多数其它传统的RPC框架并发如此。

2. gRPC具有开箱即用的高性能框架。

   高性能体现在两个方面：

   一是使用protobuf作为数据交换格式，它是一种非常高效的二进制编码格式，比JSON快得多。

   二是gRPC构建在HTTP/2上，提供了大规模的高性能基础。（gRPC比JSON快5倍）

   1. 使用单个长期TCP连接发送多个信息流，这使得gRPC框架使用少量TPC连接处理许多并发RPC调用。



## gRPC流程

![](F:/study/面试/img/框架/Screenshot 2024-06-20 105100.png)

gRPC工具生成的客户端代码：client stub--客户端存根。gRPC将传递到客户端存根的数据编码到协议缓冲区并将其发送到低级传输层。gRPC通过HTTP/2 帧流的形式发送数据。

> gRPC这么简单快速为什么没有在Web客户端和Web服务器中广泛使用？

一个原因是gRPC依赖于HTTP/2原语的较低级别的访问，目前没有浏览器支持这种级别，可以通过代理来实现（gRPC-Web）。