# 微服务

## 一、RPC 

> ### 简介

- 远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议
- 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程
- 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用

> ### 流行框架对比

![](image-micrsrc\屏幕截图 2024-02-14 223509.png)



### golang 官方库

- golang中实现RPC非常简单，官方提供了封装好的库，还有一些第三方的库

- golang官方的net/rpc库使用`encoding/gob`进行编解码，支持tcp和http数据传输方式，由于其他语言不支持gob编解码方式，所以golang的RPC只支持golang开发的服务器与客户端之间的交互

- 官方还提供了net/rpc/jsonrpc库实现RPC方法，**jsonrpc采用JSON进行数据编解码，因而支持跨语言调用，目前jsonrpc库是基于tcp协议实现的，暂不支持http传输方式**

  例题：golang实现RPC程序，实现求矩形面积和周长

> - golang写RPC程序，必须符合4个基本条件，不然RPC用不了
>   - 结构体字段首字母要大写，可以别人调用
>   - 函数名必须首字母大写
>   - 函数第一参数是接收参数，第二个参数是返回给客户端的参数，必须是指针类型
>   - 函数还必须有一个返回值error

**net/rpc**

```go
// 客户端核心代码
	conn, err := rpc.DialHTTP("tcp", ":8080")
	if err != nil {
		log.Panicln(err)
	}
	// 调用方法
	// 计算面积
	ret := 0
	err2 := conn.Call("Rect.Area", Params{50, 100}, &ret)
	if err2 != nil {
		log.Fatal(err2)
	}
	fmt.Println("面积:", ret)

// 服务端核心代码
	rect := new(Rect)
	rpc.Register(rect)
	// 绑定到http协议上
	rpc.HandleHTTP()
	// 监听服务
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Panicln(err)
	}
```



**net/rpc/jsonrpc:**

不支持http，只支持tcp

```go
// 服务端
rpc.Register(new(Rect1))
	lis, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Panicln(err)
	}
	for {
		conn, err := lis.Accept()
		if err != nil {
			continue
		}
		go func(conn net.Conn) {
			fmt.Println("new client")
			jsonrpc.ServeConn(conn)
		}(conn)
	}

// 客户端
conn, err := jsonrpc.Dial("tcp", ":8080")
```





### 自己实现RPC

RPC服务端代码：

```go
package rpc

import (
    "fmt"
    "net"
    "reflect"
)

// 声明服务端
type Server struct {
    // 地址
    addr string
    // map 用于维护关系的
    funcs map[string]reflect.Value
}

// 构造方法
func NewServer(addr string) *Server {
    return &Server{addr: addr, funcs: make(map[string]reflect.Value)}
}

// 服务端需要一个注册Register
// 第一个参数函数名，第二个传入真正的函数
func (s *Server) Register(rpcName string, f interface{}) {
    // 维护一个map
    // 若map已经有键了
    if _, ok := s.funcs[rpcName]; ok {
        return
    }
    // 若map中没值，则将映射加入map，用于调用
    fVal := reflect.ValueOf(f)
    s.funcs[rpcName] = fVal
}

// 服务端等待调用的方法
func (s *Server) Run() {
    // 监听
    lis, err := net.Listen("tcp", s.addr)
    if err != nil {
        fmt.Printf("监听 %s err :%v", s.addr, err)
        return
    }
    for {
        // 服务端循环等待调用
        conn, err := lis.Accept()
        if err != nil {
            return
        }
        serSession := NewSession(conn)
        // 使用RPC方式读取数据
        b, err := serSession.Read()
        if err != nil {
            return
        }
        // 数据解码
        rpcData, err := decode(b)
        if err != nil {
            return
        }
        // 根据读到的name，得到要调用的函数
        f, ok := s.funcs[rpcData.Name]
        if !ok {
            fmt.Println("函数 %s 不存在", rpcData.Name)
            return
        }
        // 遍历解析客户端传来的参数,放切片里
        inArgs := make([]reflect.Value, 0, len(rpcData.Args))
        for _, arg := range rpcData.Args {
            inArgs = append(inArgs, reflect.ValueOf(arg))
        }
        // 反射调用方法
        // 返回Value类型，用于给客户端传递返回结果,out是所有的返回结果
        out := f.Call(inArgs)
        // 遍历out ，用于返回给客户端，存到一个切片里
        outArgs := make([]interface{}, 0, len(out))
        for _, o := range out {
            outArgs = append(outArgs, o.Interface())
        }
        // 数据编码，返回给客户端
        respRPCData := RPCData{rpcData.Name, outArgs}
        bytes, err := encode(respRPCData)
        if err != nil {
            return
        }
        // 将服务端编码后的数据，写出到客户端
        err = serSession.Write(bytes)
        if err != nil {
            return
        }
    }
}
```











### gRPC

> - gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统
> - gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用
> - 微服务架构中，由于每个服务对应的代码库是独立运行的，无法直接调用，彼此间的通信就是个大问题
> - gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol buffers，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）
> - 可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型

> #### 1. gRPC 和 Protobuf

```shell
https://github.com/protocolbuffers/ProtoBuf/releases
# 注意：我们需要将下载得到的可执行文件protoc所在的 bin 目录加到我们电脑的环境变量中。

# 下载编译go语言的工具包
go get github.com/golang/protobuf/protoc-gen-go 
# 或者
go install google.golang.org/ProtoBuf/cmd/protoc-gen-go@latest

protoc --go_out=. hello.proto

# 安装grpc
go get google.golang.org/grpc

# 编译proto文件
protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative user.proto
```



项目结构

```go
web
├── client
│   └── main.go
├── go.mod
├── go.sum  
├── proto
│   ├── hello.proto
│   ├── pb
│   │   └── proto_demo
│   │       ├── hello.pb.go
│   │       └── user.pb.go
│   └── user.proto
└── server
    └── main.go
```









## 二、Protobuf

> **Protobuf (Protocol buffers)**是解决这个问题的灵活、高效、自动化的解决方案。使用Protocol buffers，你编写一个描述要存储的数据结构的`.proto`文件。然后，Protocol buffer编译器会创建一个类，该类实现了Protocol buffer数据的自动编码和解析，使用高效的二进制格式。生成的类为构成Protocol buffer的字段提供了获取器和设置器，并处理了读取和写入Protocol buffer的细节。重要的是，Protocol buffer格式支持随着时间的推移扩展格式的想法，以使代码仍然能够读取使用旧格式编码的数据。



### 2.0 安装

```shell
# 安装编码器
# 下载相关包
go get github.com/golang/protobuf/protoc-gen-go
```



### 2.1 版本区别

【区别1】该文件的第一行指定您正在使用proto3语法：如果您不这样做，protocol buffer编译器将假定您使用的是proto2。这必须是文件的第一个非空、非注释行。
【区别2】proto3取消了proto2的required，而proto3的singular就是proto2的optional。
【区别3】proto3 repeated标量数值类型默认packed，而proto2默认不开启。
【区别4】proto3增加了Kotlin，Ruby，Objective-C，C#，Dart的支持
【区别5】proto2可以选填default，而proto3只能使用系统默认的。（序列化后如果是默认值是不会占用空间的，对于proto2来说处理就很麻烦了）
【区别6】proto3必须有一个零值，以便我们可以使用 0 作为数字默认值。零值需要是第一个元素，以便与proto2语义兼容，其中第一个枚举值始终是默认值。proto2则没有这项要求。
【区别7】proto3在3.5版本之前会丢弃未知字段。但在 3.5 版本中，重新引入了未知字段的保留以匹配 proto2 行为。在 3.5 及更高版本中，未知字段在解析过程中保留并包含在序列化输出中。
【区别8】proto3移除了proto2的扩展，新增了Any（仍在开发中）和JSON映射。

### 2.2 入门案例

编写 proto 代码

```protobuf
syntax = "proto3";

package hello;

option go_package = "./;hello";

message Say {
int64 id = 1;
string hello = 2;
repeated string word = 3; 
}
```

进入到所在目录

```shell
protoc --go_out=. hello.proto
```

### 2.3 进阶

```protobuf
syntax = "proto3";

package hello; // 定义包名用于proto

option go_package = "./;hello"; // 定义go包名，用于生成.pd.go文件

message Say {                  // 定义消息体
int64 id = 1;
string hello = 2;
repeated string word = 3;   // 字符串数组定义
}
```

在ProtoBuf消息中定义数组类型，是通过在字段前面增加`repeated`关键词实现，标记当前字段是一个数组。

只要使用repeated标记类型定义，就表示数组类型。

#### 数据类型

rotoBuf支持多种数据类型，例如：string、int32、double、float等等，我整理了一份ProtoBuf和go语言的数据类型映射表

| .proto Type | Go Type | 使用技巧                                                     |
| ----------- | ------- | ------------------------------------------------------------ |
| double      | float64 | 没特殊技巧，记住float对应go的float32，double对应go的float64就可以了 |
| float       | float32 | 没特殊技巧，记住float对应go的float32，double对应go的float64就可以了 |
| int32       | int32   | 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 |
| uint32      | uint32  | 使用变长编码                                                 |
| uint64      | uint64  | 使用变长编码                                                 |
| sint32      | int32   | 使用变长编码，这些编码在负值时比int32高效的多                |
| sint64      | int64   | 使用变长编码，有符号的整型值。编码时比通常的int64高效。      |
| fixed32     | uint32  | 总是4个字节，如果数值都比228大的话，这个类型会比uint32高效。 |
| fixed64     | uint64  | 总是8个字节，如果数值都比256大的话，这个类型会比uint64高效。 |
| sfixed32    | int32   | 总是4个字节                                                  |
| sfixed64    | int64   | 总是8个字节                                                  |
| bool        | bool    | 严格对应，玩不出其他花样来                                   |
| string      | string  | 一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。         |
| bytes       | []byte  | 可以包含任意顺序的字节数组                                   |

#### 分配标识号

消息体后面跟着的数字就是“分配表示号”；在消息定义中每个字段后面都有一个唯一的数字，这个是标识号。

#### 保留标识号

我们想保留一些标识号，留给以后用

```protobuf
message Test {
 reserverd 2,5,7 to 10 //保留2,5,7到10这些标识号
}
```



#### 消息编译

编译命令格式：

```shell
protoc [OPTION] PROTO_FILES

protoc --go_out=. hello.proto
```

常用的OPTION选项：

```go
go复制代码  --go_out=OUT_DIR            指定代码生成目录，生成 Go 代码
  --cpp_out=OUT_DIR           指定代码生成目录，生成 C++ 代码
  --csharp_out=OUT_DIR        指定代码生成目录，生成 C# 代码
  --java_out=OUT_DIR          指定代码生成目录，生成 java 代码
  --js_out=OUT_DIR            指定代码生成目录，生成 javascript 代码
  --objc_out=OUT_DIR          指定代码生成目录，生成 Objective C 代码
  --php_out=OUT_DIR           指定代码生成目录，生成 php 代码
  --python_out=OUT_DIR        指定代码生成目录，生成 python 代码
  --ruby_out=OUT_DIR          指定代码生成目录，生成 ruby 代码
```



#### 枚举类型

```go
syntax = "proto3";//指定版本信息，非注释的第一行

enum SexType //枚举消息类型，使用enum关键词定义,一个性别类型的枚举类型
{
    UNKONW = 0; //proto3版本中，首成员必须为0，成员不应有相同的值
    MALE = 1;  //1男
    FEMALE = 2; //2女  0未知
}

// 定义一个用户消息
message UserInfo
{
    string name = 1; // 姓名字段
    SexType sex = 2; // 性别字段，使用SexType枚举类型
}
```

#### 消息嵌套

```protobuf
// 定义Article消息
message Article {
  string url = 1;
  string title = 2;
  repeated string tags = 3; // 字符串数组类型
}

// 定义ListArticle消息
message ListArticle {
  // 引用上面定义的Article消息类型，作为results字段的类型
  repeated Article articles = 1; // repeated关键词标记，说明articles字段是一个数组
}
---------------------------
message ListArticle {
  // 嵌套消息定义
  message Article {
    string url = 1;
    string title = 2;
    repeated string tags = 3;
  }
  // 引用嵌套的消息定义
  repeated Article articles = 1;
}


```

#### 定义多个proto

将消息定义写在不同的proto文件中，在需要的时候可以通过import导入其他proto文件定义的消息。

#### map 类型

map 字段不能使用`repeated`关键字修饰

```protobuf
map<key_type, value_type> map_field = N;
```



### 2.4 实战

编写user_info.proto

```protobuf
syntax = "proto3";

package demo;

option go_package = "./;user";

message UserInfo {
  int64 id = 1;     // id
  string name = 2;  // 用户名
  string phone = 3; // 电话号码
  string email = 4; // 邮箱
  int32 level = 5;  // 总经验值
  map<string, int32> score = 6;//学习分数
}
```

生成代码：

```shell
protoc --go_out=. user_info.proto
```

编写go

```go
func main() {
	// 初始化proto中的消息
	userInfo := &user.UserInfo{}

	// 常规赋值
	userInfo.Id = 1
	userInfo.Name = "testMan"
	userInfo.Email = "ttttt@testEmail.com"
	userInfo.Phone = "16532489657"
	userInfo.Level = 0

	// 在go中声明实例化map赋值给ProtoBuf消息中定义的map
	score := make(map[string]int32)
	score["demo"] = 100
	score["test"] = 200
	userInfo.Score = score

	fmt.Println("userInfo(String):", userInfo.String())

	// 转换成二进制文件
	ms, err := proto.Marshal(userInfo)
	if err != nil {
		return
	}
	fmt.Println("userInfo(Binary):", ms)

	// 二进制文件转成结构体
	newUserInfo := &user.UserInfo{}
	err = proto.Unmarshal(ms, newUserInfo)
	if err != nil {
		return
	}
	fmt.Println("userInfo(string by decode):", newUserInfo)
}
```

#### 时间格式

> proto本身的数据结构int64和int32可以用来表示时间戳，但只能精确到秒，如果想要更加的精确要导入包。

在`.proto`文件中导入包：

```protobuf
import public "google/protobuf/timestamp.proto";
message person{
  google.protobuf.Timestamp birthday = 1;
}
```

对应生成的 **.pb.go** 文件中类型为*`timestamp.Timestamp`：

```go
Person struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Birthday *timestamp.Timestamp `protobuf:"bytes,1,opt,name=birthday,proto3" json:"birthday,omitempty"`
}
```

其中，`timestamp.Timestamp`的 message 类型定义如下

```go
Copy Highlighter-hljsmessage Timestamp {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  int64 seconds = 1;

  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
}
```

go 语言 `time.Time` 类型与 `timestamp.Timestamp`互相转换使用`github.com/golang/protobuf/ptypes`包下方法：

```go
Copy Highlighter-hljspackage pb

import (
	"fmt"
	"github.com/golang/protobuf/ptypes"
	"time"
)

func TimeStampFeature() {
	//Timestamp 转 Time
	//获取的是系统时区的时间戳
	pbTimestamp := ptypes.TimestampNow()
	//此方法默认 UTC 时区
	goTime, _ := ptypes.Timestamp(pbTimestamp)
	//设定为系统时区
	fmt.Println(goTime.Local())

	//Time 转 Timestamp
	goTime2 := time.Now()
	pbTimestamp2, _ := ptypes.TimestampProto(goTime2)
	fmt.Println(pbTimestamp2)
}
```

输出为：

```diff
Copy Highlighter-hljs=== RUN   TestTimeStampFeature
2020-10-26 14:10:48.69129 +0800 CST
seconds:1603692648  nanos:691445000
--- PASS: TestTimeStampFeature (0.00s)
PASS
```

#### 秒级时间戳

若只时间处理只精确到秒，则不必使用 `time.Time`和`timestamp.Timestamp`来处理和传输时间戳，直接使用 `int32`或 `int64`来表示秒级时间戳，免去类型互相转换。



## 分布式一致性算法

> 强一致性算法：Raft、Paxos、ZAB，保证系统改变提交以后立即改变集群的状态。
>
> ### **一致性算法实现举例**
>
> - Google的Chubby分布式锁服务，采用了Paxos算法
> - etcd分布式键值数据库，采用了Raft算法
> - ZooKeeper分布式应用协调服务，Chubby的开源实现，采用ZAB算法

### Raft



### Paxos

> 背景：Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法，使其获得2013年图灵奖。
>
> Paxos由Lamport于1998年在《The Part-Time Parliament》论文中首次公开，最初的描述使用希腊的一个小岛Paxos作为比喻，描述了Paxos小岛中通过决议的流程，并以此命名这个算法，但是这个描述理解起来比较有挑战性。后来在2001年，Lamport觉得同行不能理解他的幽默感，于是重新发表了朴实的算法描述版本《Paxos Made Simple》。
>
> 自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。
>
> 然而，Paxos的最大特点就是难，不仅难以理解，更难以实现。

。。。





### ZAB

