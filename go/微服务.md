# 微服务

## RPC 

> ### 简介

- 远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议
- 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程
- 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用

> ### 流行框架对比

![](image-micrsrc\屏幕截图 2024-02-14 223509.png)



### golang 官方库

- golang中实现RPC非常简单，官方提供了封装好的库，还有一些第三方的库

- golang官方的net/rpc库使用`encoding/gob`进行编解码，支持tcp和http数据传输方式，由于其他语言不支持gob编解码方式，所以golang的RPC只支持golang开发的服务器与客户端之间的交互

- 官方还提供了net/rpc/jsonrpc库实现RPC方法，**jsonrpc采用JSON进行数据编解码，因而支持跨语言调用，目前jsonrpc库是基于tcp协议实现的，暂不支持http传输方式**

  例题：golang实现RPC程序，实现求矩形面积和周长

> - golang写RPC程序，必须符合4个基本条件，不然RPC用不了
>   - 结构体字段首字母要大写，可以别人调用
>   - 函数名必须首字母大写
>   - 函数第一参数是接收参数，第二个参数是返回给客户端的参数，必须是指针类型
>   - 函数还必须有一个返回值error

**net/rpc**

```go
// 客户端核心代码
	conn, err := rpc.DialHTTP("tcp", ":8080")
	if err != nil {
		log.Panicln(err)
	}
	// 调用方法
	// 计算面积
	ret := 0
	err2 := conn.Call("Rect.Area", Params{50, 100}, &ret)
	if err2 != nil {
		log.Fatal(err2)
	}
	fmt.Println("面积:", ret)

// 服务端核心代码
	rect := new(Rect)
	rpc.Register(rect)
	// 绑定到http协议上
	rpc.HandleHTTP()
	// 监听服务
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Panicln(err)
	}
```



**net/rpc/jsonrpc:**

不支持http，只支持tcp

```go
// 服务端
rpc.Register(new(Rect1))
	lis, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Panicln(err)
	}
	for {
		conn, err := lis.Accept()
		if err != nil {
			continue
		}
		go func(conn net.Conn) {
			fmt.Println("new client")
			jsonrpc.ServeConn(conn)
		}(conn)
	}

// 客户端
conn, err := jsonrpc.Dial("tcp", ":8080")
```





### 自己实现RPC















### gRPC

> - gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统
> - gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用
> - 微服务架构中，由于每个服务对应的代码库是独立运行的，无法直接调用，彼此间的通信就是个大问题
> - gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol buffers，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）
> - 可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型

> #### 1. gRPC 和 Protobuf

```shell
https://github.com/protocolbuffers/ProtoBuf/releases
# 注意：我们需要将下载得到的可执行文件protoc所在的 bin 目录加到我们电脑的环境变量中。

# 下载编译go语言的工具包
go get github.com/golang/protobuf/protoc-gen-go 
# 或者
go install google.golang.org/ProtoBuf/cmd/protoc-gen-go@latest

protoc --go_out=. hello.proto
```











## 二、Protobuf

> **Protobuf (Protocol buffers)**是解决这个问题的灵活、高效、自动化的解决方案。使用Protocol buffers，你编写一个描述要存储的数据结构的`.proto`文件。然后，Protocol buffer编译器会创建一个类，该类实现了Protocol buffer数据的自动编码和解析，使用高效的二进制格式。生成的类为构成Protocol buffer的字段提供了获取器和设置器，并处理了读取和写入Protocol buffer的细节。重要的是，Protocol buffer格式支持随着时间的推移扩展格式的想法，以使代码仍然能够读取使用旧格式编码的数据。

### 2.1 基本规范











## 分布式一致性算法

> 强一致性算法：Raft、Paxos、ZAB，保证系统改变提交以后立即改变集群的状态。
>
> ### **一致性算法实现举例**
>
> - Google的Chubby分布式锁服务，采用了Paxos算法
> - etcd分布式键值数据库，采用了Raft算法
> - ZooKeeper分布式应用协调服务，Chubby的开源实现，采用ZAB算法

### Raft



### Paxos

> 背景：Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法，使其获得2013年图灵奖。
>
> Paxos由Lamport于1998年在《The Part-Time Parliament》论文中首次公开，最初的描述使用希腊的一个小岛Paxos作为比喻，描述了Paxos小岛中通过决议的流程，并以此命名这个算法，但是这个描述理解起来比较有挑战性。后来在2001年，Lamport觉得同行不能理解他的幽默感，于是重新发表了朴实的算法描述版本《Paxos Made Simple》。
>
> 自Paxos问世以来就持续垄断了分布式一致性算法，Paxos这个名词几乎等同于分布式一致性。Google的很多大型分布式系统都采用了Paxos算法来解决分布式一致性问题，如Chubby、Megastore以及Spanner等。开源的ZooKeeper，以及MySQL 5.7推出的用来取代传统的主从复制的MySQL Group Replication等纷纷采用Paxos算法解决分布式一致性问题。
>
> 然而，Paxos的最大特点就是难，不仅难以理解，更难以实现。

。。。





### ZAB

