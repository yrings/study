# 系统结构

## 虚拟地址是什么？

**虚拟内存**：**虚拟内存是一种逻辑上扩充物理内存的技术**。基本思想是用软、硬件技术把内存与外存这两级存储器当做一级存储器来用。虚拟内存技术的实现利用了自动覆盖和交换技术。简单的说就是将硬盘的一部分作为内存来使用。

**虚拟地址空间**：在32位的`i386 CPU`的地址总线的是32位的，也就是说可以寻找到`4G`的地址空间。我们的程序被CPU执行，就是在`0x00000000`到`0xFFFFFFFF`这一段地址中。高`2G`的空间为内核空间，由操作系统调用，低`2G`的空间为用户空间，由用户使用。

​	CPU在寻址的时候，是按照虚拟地址来寻址，然后通过**MMU(内存管理单元)**将虚拟地址转换为物理地址。因为只有程序的一部分加入到内存中，所以会出现所寻找的地址不在内存中的情况（CPU产生缺页异常），如果在内存不足的情况下，就会通过**页面调度算法**来将内存中的页面置换出来，然后将在外存中的页面加入到内存中，使程序继续正常运行。

物理地址空间是物理内存的范围，虚拟地址空间是虚拟内存的范围，物理地址空间中的每个物理地址都是实打实地指向了具体的存储单元，虚拟地址空间中每个虚拟地址指向哪里有3种情况:

a.未分配,这个虚拟地址仅仅是个数字而已，没有任何指向。

b.未缓冲,这个虚拟地址指向了磁盘的某个字节存储单元，里面存储了指令或者数据。

c.已缓冲,这个虚拟地址指向了物理内存的某个字节存储单元，里面存储了指令或者数据。

**虚拟页，物理页，页表**

现代操作操作和CPU将物理内存按照固定的页大小分成很多份,每一份叫做物理页(PP)，每一份有一个编号叫做物理页号(PPN),这个物理页大小通常是4KB,例如一个物理内存大小为20KB，这个物理内存可以分成5个物理页，那么物理页号(PPN)就是0,1,2,3,4。

虚拟内存也一样，它的页大小与物理内存的页大小相同，虚拟内存也被分成了很多份,每一份叫做虚拟页(VP),每一份的编号叫做虚拟页号(VPN),例如假设虚拟页大小为4KB，一个虚拟内存大小为10KB，这个虚拟内存可以分成2个虚拟页(VP),虚拟页号(VPN)就是0,1

页表是建立虚拟页号和物理页号映射关系的表结构，每个页表项(PTE)包括了有效位，物理页号，磁盘地址等信息。

## 页面调度算法

先进先出置换算法（FIFO

最近最久未使用的置换算法（LRU）

时钟页面置换算法

**该算法的思路是，把所有的页面都保存在⼀个类似钟面的「环形链表」中，⼀个表针指向最老的页面。**

## 用户态与内核态之间切换

用户空间和内核空间
用户程序有用户态和内核态两种状态。用户态就是执行在用户空间中，不能直接执行系统调用。必须先切换到内核态，也就是系统调用的相关数据信息必须存储在内核空间中，然后执行系统调用。

操作硬盘等资源属于敏感操作，为了内核安全，用户线程不能直接调用。而是采用了操作系统内核提供了系统调用接口，用户线程通过系统调用来实现文件读写。所以直接与硬盘打交道的是操作系统内核。

操作系统将线程分为了内核态和用户态，当用户线程调用了系统调用的时候，需要将线程从用户态切换到内核态。

**无论是操作系统内核程序还是用户程序在运行的时候都需要申请内存来保存运行状态，调用方法信息、程序代码、数据等信息。**

**操作系统将内存分为内核空间和用户空间。**

内核空间中主要负责 操作系统内核线程以及用户程序系统调用。

用户空间主要负责用户程序的非系统调用。

内核空间比用户空间拥有更高的操作级别，只有在内核空间中才可以调用操作硬件等核心资源。

操作系统将内存按1：3的比例分为了内核空间和用户空间，用户态的运行栈信息保存在用户空间中，内核态的运行栈信息保存在内核空间中。运行栈中保存了当前线程的运行信息，比如执行到了哪些方法，局部变量等。

当发生用户态和内核态之间的切换的时候，运行栈的信息发生了变化，对应的CPU中的寄存器信息也要发生变换。但是用户线程完成系统调用的时候，还是要切换回用户态，继续执行代码的。所以要将发生系统调用之前的用户栈的信息保存起来，也就是将寄存器中的数据保存到线程所属的某块内存区域。**这就涉及到了数据的拷贝，同时用户态切换到内核态还需要安全验证等操作**。所以用户态和内核态之间的切换是十分耗费资源的。

用户态切换到内核态


CPU中有一个标志字段，标志着线程的运行状态。用户态和内核态对应着不同的值，用户态为3，内核态为0.

每个线程都对应着一个用户栈和内核栈，分别用来执行用户方法和内核方法。
用户方法就是普通的操作。
内核方法就是访问磁盘、内存分配、网卡、声卡等敏感操作。

当用户尝试调用内核方法的时候，就会发生用户态切换到内核态的转变。

![](image\4285b066dca247c8a22f98dd6040bb8e.png)

切换流程：
1、每个线程都对应这一个TCB，TCB中有一个TSS字段，存储着线程对应的内核栈的地址，也就是内核栈的栈顶指针。

2、因为从用户态切换到内核态时，首先用户态可以直接读写寄存器，用户态操作CPU，将寄存器的状态保存到对应的内存中，然后调用对应的系统函数，传入对应的用户栈的PC地址和寄存器信息，方便后续内核方法调用完毕后，恢复用户方法执行的现场。

3、将CPU的字段改为内核态，将内核段对应的代码地址写入到PC寄存器中，然后开始执行内核方法，相应的方法栈帧时保存在内核栈中。

4、当内核方法执行完毕后，会将CPU的字段改为用户态，然后利用之前写入的信息来恢复用户栈的执行。

从上述流程可以看出用户态切换到内核态的时候，会牵扯到用户态现场信息的保存以及恢复，还要进行一系列的安全检查，比较耗费资源。

![](F:\study\go\image\3cf4a487404c4f98a8b95bf7016b723c.png)

















