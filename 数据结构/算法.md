# 算法

## 1、数组

### 1.1 数组理论基础

> 数组的特点：
>
> * 数组下标都是从零开始的
>
> * 数组内的空间的地址是连续的，所以在增删数据时，就可能要移动其它元素的地址，所以说数组的元素是不能删除的，只能覆盖。
>
> * 二维数组在内存空间的空间地址是否是连续的？
>
>   不同语言是不同的，就Java来说是不连续的（Java没有指针，地址不对程序员暴露，寻址操作完全交给虚拟机）

Java的二维数组的排序方式像是如图所示：

![](images\20201214111631844.png)

### 1.2 二分查找

> 入门案例：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
static int search(int[] nums,int target){
        if(nums[0] > target || nums[nums.length -1] < target){
            return -1;
        }
        int left = 0;
        int right = nums.length;

        while (left <= right) {
            int mid = left + ((right-left) >> 1);//可以防止溢出，等同于(left + right)/2
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] > target){
                right = mid -1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
```

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。

**Go:**

```go
func search(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    index := (right - left) / 2
    for left <= right{
        index = (right + left) / 2 
        if nums[index] == target {
            return index
        } else if nums[index] > target{
            right = index - 1
        } else {
            left = index + 1
        }
    }
     return -1
}
```

### 1.3 移除元素

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
>
> 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

* solution 1:两个for循环遍历

  时间复杂度 O（n ^ 2）

  空间复杂度O（1）

* 双指针

  双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  定义快慢指针

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新 新数组下标的位置

  时间复杂度：O(n)

  空间复杂度：O(1)

  ```java
  public int removeElement(int[] nums, int val) {
          int slowIndex = 0;
          for(int flashIndex = 0; flashIndex < nums.length; flashIndex++){
              if(nums[flashIndex] != val) {
                  nums[slowIndex] = nums[flashIndex];
                  slowIndex++;
              }
          }
          return slowIndex;
      }
  ```




**Go:**

```go
// 方法一；快慢指正,
/* 
要注意边界
*/
func removeElement(nums []int, val int) int {
    fastIndex := 0
    slowIndex := 0
    for ; fastIndex < len(nums); fastIndex++ {
        if nums[fastIndex] != val {
            nums[slowIndex] = nums[fastIndex]
            slowIndex++
        }
    }
    return slowIndex
}
// 方法二: 头尾指针
func removeElement(nums []int, val int) int {
    left := 0
    right := len(nums)
    for left < right{
        if nums[left] == val{
                nums[left] = nums[right-1]
                right--

        }else{
            left++
        }
    }
    return left
}
```



### 1.4 有序数组的平方

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
>
> 示例 1：
>
> - 输入：nums = [-4,-1,0,3,10]
> - 输出：[0,1,9,16,100]
> - 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
>
> 示例 2：
>
> - 输入：nums = [-7,-3,2,3,11]
> - 输出：[4,9,9,49,121]

双指针法：

![](images\977.有序数组的平方.gif)

时间复杂度为O(n)，相对于暴力排序的解法O(n + nlog n)提升不少

```java
public int[] sortedSquares(int[] nums) {
        int[] result = new int[nums.length];
        int index = nums.length - 1;
        // 设置双指针
        int i = 0;
        int j = nums.length - 1;

        while(i <= j) {
            if((nums[i] * nums[i]) < (nums[j] * nums[j])){
                result[index] = nums[j] * nums[j];
                j--;
            } else{
                result[index] = nums[i] * nums[i];
                i++;
            }
            index--;
        }
        return result;
    }
```

**Go：**

记录头尾两边为放入数组的索引，两边对应数组中的数进行比较，将较大放入结果数组，并且索引变化。遍历整个数组。

```go
func sortedSquares(nums []int) []int {
    left := 0
    len := len(nums)
    right := len - 1
    resArry := make([]int,len)
    endIndex := len - 1
    for left <= right {
        if nums[left] * nums[left] < nums[right]*nums[right] {
            resArry[endIndex] = nums[right]*nums[right]
            right--
        } else {
            resArry[endIndex] = nums[left]*nums[left]
            left++
        }
        endIndex--
    }
    return resArry
}
```







### 1.5 长度最小的子数组

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
>
> 示例：
>
> - 输入：s = 7, nums = [2,3,1,2,4,3]
> - 输出：2
> - 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

#### 滑动窗口

![](images\209.长度最小的子数组.gif)

可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

```java
   public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                result = Math.min(result, right - left + 1);
                sum -= nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
```

**Go:**

```go
func minSubArrayLen(target int, nums []int) int {
    sum := 0
    left := 0
    minRes := len(nums) + 1

    for right := 0; right < len(nums); right++ {
        sum += nums[right]
        for sum >= target {
            if right - left < minRes {
                minRes = right - left + 1
            }
            sum -= nums[left]
            left++
        }
    }
    if minRes == len(nums) + 1 {
        return 0
    }
    return minRes
}
```





### 1.6 螺旋矩阵

> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

> line、row行；column列

**模拟行为**：

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

![](images\20220922102236.png)

```java
public int[][] generateMatrix(int n) {
         int loop = 0;  // 控制循环次数
        int[][] res = new int[n][n];
        int start = 0;  // 每次循环的开始点(start, start)
        int count = 1;  // 定义填充数字
        int i, j;

        while (loop++ < n / 2) { // 判断边界后，loop从1开始
            // 模拟上侧从左到右
            for (j = start; j < n - loop; j++) {
                res[start][j] = count++;
            }
            // 模拟右侧从上到下
            for (i = start; i < n - loop; i++) {
                res[i][j] = count++;
            }

            // 模拟下侧从右到左
            for (; j >= loop; j--) {
                res[i][j] = count++;
            }
            // 模拟左侧从下到上
            for (; i >= loop; i--) {
                res[i][j] = count++;
            }
            start++;
        }
        if (n % 2 == 1) {
            res[start][start] = count;
        }
        return res;
    }
```

**Go：**

```go
func generateMatrix(n int) [][]int {
    num := 1
    // 记录当前圈数的阶级
    cla := n
    resAry := make([][]int, n)
    for h := 0; h < n; h++{
        resAry[h] = make([]int, n)
    }
    right:= 0
    bottom := n - 1

    for cla > 0 {
        if cla == 1 {
            resAry[right][right] = num
            break
        }
        for i := right; i < right + cla - 1; i++ {
            resAry[right][i] = num
            num++
        }
        for j := right ; j < right + cla - 1; j++ {
            resAry[j][bottom] = num
            num++
        }
        for k :=  bottom; k > bottom - cla + 1; k-- {
            resAry[bottom][k] = num
            num++
        }
        for u := bottom; u > bottom - cla + 1; u-- {
            resAry[u][right] = num
            num++
        }
        cla -= 2
        right++
        bottom--
    }
    return resAry
}
```





> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```java
public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        List<Integer> res = new ArrayList<>();
        int line_loop = m / 2;
        int column_loop = n / 2;
        int loop = 0;
        int start = 0;
        int i,j; 
        
        if(m == 1 & n == 1){
            res.add(matrix[0][0]);
            return res;
        } else if(m == 1) {
            for(int k = 0; k < n;k++){
                res.add(matrix[0][k]);
            }
            return res;
        } else if(n == 1){
            for(int k = 0; k < m;k++){
                res.add(matrix[k][0]);
            }
            return res;
        }

        while(loop++ < Math.min(line_loop,column_loop)) {
            
            for(j = start;j < n - loop; j++){
                res.add(matrix[start][j]);
            }

            for(i = start;i < m - loop; i++){
                res.add(matrix[i][j]);
            }

            for(;j >= loop ;j--){
                res.add(matrix[i][j]);
            }

            for(;i >= loop ;i--){
                res.add(matrix[i][j]);
            }
            start++;
        }
        if(Math.min(m,n) % 2 == 1){
            int line = start;
            int column = start;
            if(line_loop == column_loop) {
                res.add(matrix[line][column]); 
            } else if(line_loop < column_loop){
                for(int k = 0;k < (n - m + 1) ;k++){
                    res.add(matrix[line][column]);
                    column++;
                }
            } else{
                for(int k = 0; k < (m - n + 1);k++){
                    res.add(matrix[line][column]);
                    line++;
                }
            }
        }
        return res;
    }
```

方法二：

> 算法流程：
> 空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。
> 初始化： 矩阵 左、右、上、下 四个边界 left , right , top , bottom ，用于打印的结果列表 res 。
> 循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。
> 根据边界打印，即将元素按顺序添加至列表 res 尾部。
> 边界向内收缩 1 （代表已被打印）。
> 判断边界是否相遇（是否打印完毕），若打印完毕则跳出。
> 返回值： 返回 res 即可。
> 打印方向	1. 根据边界打印	2. 边界向内收缩	3. 是否打印完毕
> 从左向右	左边界l ，右边界 r	上边界 t 加 111	是否 t > b
> 从上向下	上边界 t ，下边界b	右边界 r 减 111	是否 l > r
> 从右向左	右边界 r ，左边界l	下边界 b 减 111	是否 t > b
> 从下向上	下边界 b ，上边界t	左边界 l 加 111	是否 l > r

```java
public List<Integer> spiralOrder(int[][] matrix) {
        if (matrix.length == 0)
            return new ArrayList<Integer>();
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0;
        Integer[] res = new Integer[(r + 1) * (b + 1)];
        while (true) {
            for (int i = l; i <= r; i++) res[x++] = matrix[t][i]; // left to right
            if (++t > b) break;
            for (int i = t; i <= b; i++) res[x++] = matrix[i][r]; // top to bottom
            if (l > --r) break;
            for (int i = r; i >= l; i--) res[x++] = matrix[b][i]; // right to left
            if (t > --b) break;
            for (int i = b; i >= t; i--) res[x++] = matrix[i][l]; // bottom to top
            if (++l > r) break;
        }
        return Arrays.asList(res);
    }
```







## 2、链表

### 2.1 链表理论基础

> 单链表、双链表、循环链表
>
> 链表在内存中的存储是非连续的

![](images\20200806195200276.png)

* java中链表的定义

```java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

### 2.2 移除链表元素

> 题意：删除链表中等于给定值 val 的所有节点。
>
> 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]
>
> 示例 2： 输入：head = [], val = 1 输出：[]
>
> 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

这里就涉及如下链表操作的两种方式：

- **直接使用原来的链表来进行删除操作。**
- **设置一个虚拟头结点在进行删除操作。**

设置一个虚拟节点：

```java
public ListNode removeElements(ListNode head, int val) {
        if(head == null){
            return head;
        }
        ListNode dummy = new ListNode(-1,head);
        ListNode pre = dummy; 
        ListNode cur = head;
        
        while(cur != null){
            if(cur.val == val){
                pre.next = cur.next;
            } else{
                pre = pre.next;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
```

**Go:**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeElements(head *ListNode, val int) *ListNode {
    
    // lastNode := &ListNode{}
    lastNode := new(ListNode)
    curNode := head

    for curNode != nil {
        if curNode.Val == val {
            if lastNode.Next != nil {
                lastNode.Next = curNode.Next
            } else {
                head = curNode.Next
            }
            curNode = curNode.Next
        } else {
            lastNode = curNode
            curNode = curNode.Next
        }
    }
    return head
}
// 建立一个虚拟头结点
func removeElements(head *ListNode, val int) *ListNode {
    dummyHead := &ListNode{}
    dummyHead.Next = head
    cur := dummyHead
    for cur != nil && cur.Next != nil {
        if cur.Next.Val == val {
            cur.Next = cur.Next.Next
        } else {
            cur = cur.Next
        }
    }
    return dummyHead.Next
}
```







### 2.3 设计链表

> 你可以选择使用单链表或者双链表，设计并实现自己的链表。
>
> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
>
> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
>
> 实现 `MyLinkedList` 类：
>
> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。
> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
> - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
> - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
> - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

```java
//单链表
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }
}
class MyLinkedList {
    //size存储链表元素的个数
    int size;
    //虚拟头结点
    ListNode head;

    //初始化链表
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点
    public int get(int index) {
        //如果index非法，返回-1
        if (index < 0 || index >= size) {
            return -1;
        }
        ListNode currentNode = head;
        //包含一个虚拟头节点，所以查找第 index+1 个节点
        for (int i = 0; i <= index; i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }

    //在链表最前面插入一个节点，等价于在第0个元素前添加
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果 index 大于链表的长度，则返回空
    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        size++;
        //找到要插入节点的前驱
        ListNode pred = head;
        for (int i = 0; i < index; i++) {
            pred = pred.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    }

    //删除第index个节点
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }
        size--;
        if (index == 0) {
            head = head.next;
	    return;
        }
        ListNode pred = head;
        for (int i = 0; i < index ; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}

//双链表
class ListNode{
    int val;
    ListNode next,prev;
    ListNode() {};
    ListNode(int val){
        this.val = val;
    }
}


class MyLinkedList {  

    //记录链表中元素的数量
    int size;
    //记录链表的虚拟头结点和尾结点
    ListNode head,tail;
    
    public MyLinkedList() {
        //初始化操作
        this.size = 0;
        this.head = new ListNode(0);
        this.tail = new ListNode(0);
        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！
        head.next=tail;
        tail.prev=head;
    }
    
    public int get(int index) {
        //判断index是否有效
        if(index<0 || index>=size){
            return -1;
        }
        ListNode cur = this.head;
        //判断是哪一边遍历时间更短
        if(index >= size / 2){
            //tail开始
            cur = tail;
            for(int i=0; i< size-index; i++){
                cur = cur.prev;
            }
        }else{
            for(int i=0; i<= index; i++){
                cur = cur.next; 
            }
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        //等价于在第0个元素前添加
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        //等价于在最后一个元素(null)前添加
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        //index大于链表长度
        if(index>size){
            return;
        }
        //index小于0
        if(index<0){
            index = 0;
        }
        size++;
        //找到前驱
        ListNode pre = this.head;
        for(int i=0; i<index; i++){
            pre = pre.next;
        }
        //新建结点
        ListNode newNode = new ListNode(val);
        newNode.next = pre.next;
        pre.next.prev = newNode;
        newNode.prev = pre;
        pre.next = newNode;
        
    }
    
    public void deleteAtIndex(int index) {
        //判断索引是否有效
        if(index<0 || index>=size){
            return;
        }
        //删除操作
        size--;
        ListNode pre = this.head;
        for(int i=0; i<index; i++){
            pre = pre.next;
        }
        pre.next.next.prev = pre;
        pre.next = pre.next.next;
    }
}
```

### 2.4 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

解法一：双指针法

 ```java
 public ListNode reverseList(ListNode head) {
 
         ListNode pre = null;
         ListNode temp;
         ListNode cur = head;
 
         while(cur != null){
             temp = cur.next;
             cur.next = pre;
             pre = cur;
             cur = temp;
         }
         return pre;
     }
 ```

解法二：递归

```java
public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
        if (cur == null) {
            return prev;
        }
        ListNode temp = null;
        temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 更新prev、cur位置
        // prev = cur;
        // cur = temp;
        return reverse(cur, temp);
    }
```

### 2.5 删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

思路是这样的，但要注意一些细节。

分为如下几步：

- 首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑.
- 定义fast指针和slow指针，初始值为虚拟头结点，如图：

![](images\19.删除链表的倒数第N个节点.png)

- fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图：

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1,head);
        ListNode fast = dummy;
        ListNode slow = dummy;

        for(int i = 0; i < n + 1 ; i++){
            fast = fast.next;
        }

        while(fast != null){
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
```

### 2.6 两两交换链表中的节点

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```java
public ListNode swapPairs(ListNode head) {

        if(head == null){
            return head;
        }
        ListNode dummy = new ListNode(-1,head);
        ListNode pre = dummy;
        ListNode cur = head;
        ListNode next = head.next;

        while(cur != null && next != null){
            pre.next = next;
            cur.next = next.next;
            next.next = cur;

            pre = cur;
            if( pre.next == null || pre.next.next == null)break;
            cur = pre.next;
            next = cur.next;
        }
        return dummy.next;
    }

public ListNode swapPairs(ListNode head) {
        ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点
        dumyhead.next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode cur = dumyhead;
        ListNode temp; // 临时节点，保存两个节点后面的节点
        ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点
        ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点
        while (cur.next != null && cur.next.next != null) {
            temp = cur.next.next.next;
            firstnode = cur.next;
            secondnode = cur.next.next;
            cur.next = secondnode;       // 步骤一
            secondnode.next = firstnode; // 步骤二
            firstnode.next = temp;      // 步骤三
            cur = firstnode; // cur移动，准备下一轮交换
        }
        return dumyhead.next;  
    }
```



递归版本：

```java
public ListNode swapPairs(ListNode head) {
        // base case 退出提交
        if(head == null || head.next == null) return head;
        // 获取当前节点的下一个节点
        ListNode next = head.next;
        // 进行递归
        ListNode newNode = swapPairs(next.next);
        // 这里进行交换
        next.next = head;
        head.next = newNode;

        return next;
    }
} 
```

### 2.7 链表相交

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

**思路**

我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

否则循环退出返回空指针。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int sizeA = 0,sizeB = 0,diff;
        ListNode temp =headA;
        ListNode es_temp;
        while(temp != null){
            temp = temp.next;
            sizeA++;
        }
        temp = headB;
        while(temp != null){
            temp = temp.next;
            sizeB++;
        }
        if(sizeA > sizeB){
            diff = sizeA - sizeB;
            temp = headA;
            es_temp = headB;
            for(int i = 0; i < diff;i++){
                temp = temp.next;
            }
            while(temp != null){
                if(temp == es_temp){
                    return temp;
                }
                temp = temp.next;
                es_temp = es_temp.next;
            }
        } else if(sizeA < sizeB){
            diff = sizeB -sizeA;
            temp = headB;
            es_temp = headA;
            for(int i = 0; i < diff;i++){
                temp = temp.next;
            }
            while(temp != null){
                if(temp == es_temp){
                    return temp;
                }
                temp = temp.next;
                es_temp = es_temp.next;
            }
        } else{
            temp = headB;
            es_temp = headA;
            while(temp != null){
                if(temp == es_temp){
                    return temp;
                }
                temp = temp.next;
                es_temp = es_temp.next;
            }
        }
        return null;
    }
```

### 2.8 ☆环形链表

> 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

**思路：**

要解决这道题关键要解决两个问题：

* 如何判断是否有环？
* 如何判断环的入口？

**如何判断有环？**

> 可以用快慢指针，分别定义fast和slow指针，都从头结点出发，slow指针一次走一步，fast一次走两步，如果两者相遇，代表有环。

**如何判断环的入口？**

* 首先可以假设头结点到入口结点的距离为x，入口结点到相遇结点的距离为y，相遇结点继续走又回到入口结点的距离为z。

  ![](images\20220925103433.png)

* 当相遇时，slow指针走过的距离为 `x+y` ,fast指针走过的距离为 `x+y+n(z+y)` ,n表示走过的圈数，（由于fast指针的速度是slow指针的两倍，所以相遇时slow指针一定是小于等于一圈的）

* 又由于fast指针的速度是slow指针的两倍，所以距离为两倍，则有

  `( x + y ) * 2 = x + y + n ( z + y) `

​		化简得：

​		`x = (n - 1) (y + z) + z`

* 从公式中可以得出一下结论，当一个指针从头结点出发，一个指针从**相遇结点**出发，每次走一步，则两者的相遇的位置一定是入口结点。



代码实现：

```java
ublic ListNode detectCycle(ListNode head) {
        ListNode slow = head,fast = head;
        ListNode temp;

        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast){//有环
                temp = head;
                while(temp != fast){
                    temp = temp.next;
                    fast = fast.next;
                }
                return temp;
            }
        }
        return null;
    }
```

## 3、哈希表

### 3.1 哈希表理论基础

> 哈希表（hash table）：
>
> 哈希表是根据关键码的值而直接进行访问的数据结构，所以哈希表的查询效率很高
>
> 哈希函数（hash function）：
>
> 将实际数据根据相应的关键码映射成哈希表就是哈希函数
>
> **一般哈希表都是用来快速判断一个元素是否出现集合里。**

#### 哈希碰撞

* 哈希碰撞是由哈希函数映射过程中延伸出来的一个问题

  现在要将学生表映射到一个哈希表中，然后通过查询索引下标快速知道同学是否存在。

  通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

  如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

  > 此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个**取模**的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。

  ![](images\2021010423484818.png)

  此时问题又来了，哈希表我们刚刚说过，就是一个数组。

  如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

  接下来**哈希碰撞**登场。

  一般解决哈希碰撞有两种方式，拉链法和线性探测法。

  * 拉链法：

    其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

  * 线性探测法：

    使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

    例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。

#### 常见的三种哈希结构

* 数组
* set（集合）
* map（映射）

在java中：

| 集合     | 特点                                   |
| :------- | -------------------------------------- |
| TreeSet  | 不允许重复元素，升序的，不是线程安全的 |
| HasheSet | 不允许重复元素，无序的，不是线程安全的 |



### 3.2 有效的字母异位词

> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。
>
> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。
>
> 示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
>
> 示例 2: 输入: s = "rat", t = "car" 输出: false

* 思路

  定义一个数组叫做record用来上记录字符串s里字符出现的次数。

  需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

  再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

  那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

  那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

  最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

  时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。

字符串的 `charAt()` 方法根据索引获取单字符。 

```java
public boolean isAnagram(String s, String t) {

        int[] letter = new int[26];

        for(int i = 0; i < s.length();i++){
            letter[s.charAt(i) - 'a']++;
        }
        for(int i = 0; i < t.length(); i++){
            letter[t.charAt(i) - 'a']--;
        }
        for(int count : letter){
            if(count != 0){
                return false;
            }
        }
        return true;
    }
```

### 3.3 两个数组的交集

> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```java
public int[] intersection(int[] nums1, int[] nums2) {

        if(nums1 == null || nums1.length == 0|| nums2 == null || nums2.length == 0){
            return new int[0];
        }
        Set<Integer> res = new HashSet<>();
        Set<Integer> temp = new HashSet<>();

        for(int i : nums1){
            temp.add(i);
        }
        for(int i : nums2){
            if(temp.contains(i) ){
                res.add(i);
            }
        }
        int[] arry = new int[res.size()];
        int j = 0;
        for(int i : res){
            arry[j++] = i; 
        }
        return arry;
    }
```

### 3.4 快乐数

> 编写一个算法来判断一个数 `n` 是不是快乐数。
>
> **「快乐数」** 定义为：
>
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
>
> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

```java
public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
```



### 3.5 两数之和

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

* **思路**

  因为本地，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，**需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适**。

  再来看一下使用数组和set来做哈希法的局限。

  - 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
  - set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

  此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

```java
public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        if(nums == null || nums.length == 0) {
            return new int[0];
        }
        Map<Integer,Integer> map = new HashMap<>();

        for(int i = 0 ; i < nums.length;i++) {
            int temp = target - nums[i];

            if(map.containsKey(temp)){
                res[0] = i;
                res[1] = map.get(temp);
            }
            map.put(nums[i],i);
        }
        return res;
    }
```



### 3.6 四数相加II

> 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
>
> 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

* 思路

  本题解题步骤：

  1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
  2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
  3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
  4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
  5. 最后返回统计值 count 就可以了

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int res = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        //统计两个数组中的元素之和，同时统计出现的次数，放入map
        for (int i : nums1) {
            for (int j : nums2) {
                int sum = i + j;
                map.put(sum, map.getOrDefault(sum, 0) + 1);
            }
        }
        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i : nums3) {
            for (int j : nums4) {
                res += map.getOrDefault(0 - i - j, 0);
            }
        }
        return res;
    }
```



### 3.7 赎金信

> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。
>
> 如果可以，返回 `true` ；否则返回 `false` 。
>
> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。



```java
public boolean canConstruct(String ransomNote, String magazine) {
        int[] letter = new int[26];

        for(int i = 0; i < magazine.length(); i++){
            letter[magazine.charAt(i) - 'a']++;
        }

        for(int i = 0; i < ransomNote.length(); i++){
            letter[ransomNote.charAt(i) - 'a']--;
            if(letter[ransomNote.charAt(i) - 'a'] < 0){
                return false;
            }
        }
        return true;
    }
```



### 3.8 ☆三数之和

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
>
> **注意：** 答案中不可以包含重复的三元组。
>
> 示例：
>
> 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
>
> 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

* 双指针法：

  ![](images\15.三数之和.gif)

> 首先将数组按照升序排序，然后有一层for循环，数组下标i作为索引，定义在i+1上的left变量，定义下标right在数组结尾的位置上。
>
> 依然还是在数组中找到abc使得a + b + c = 0；即a = nums[i]，b = nums[left]，c = nums[right]。
>
> 接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。
>
> 如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。
>
> 时间复杂度：O(n^2)。

**关于去重：**

> 去重的思想这里是判断后一个元素或者前一个元素是否相同，如果相同就跳过，即跳过这一次循环。

**a的去重：**

> a的去重一定要判断前一个是否相同，若判断后一个是否相同会忽略前两个元素相同的情况

```java
public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
	// 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.length; i++) {
	    // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) { 
                return result;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {  // 去重a
                continue;
            }

            int left = i + 1;
            int right = nums.length - 1;
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
		    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    
                    right--; 
                    left++;
                }
            }
        }
        return result;
    }
```



### 3.9 四数之和

> 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

* 思路

  前两个数用两个循环，**后两个数就可以用三数之和**]的方法

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);

        for(int i = 0; i <nums.length; i++){

            if(nums[i] > 0 && nums[i] > target){
                return res;
            }

            if(i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            for(int j = i + 1; j < nums.length; j++) {
                
            if(j > i + 1 && nums[j] == nums[j - 1] ){
                continue;
            }

            int left = j + 1;
            int right = nums.length - 1;
             
            while(left < right) {
                long sum = nums[i] + nums[j] + nums[left] + nums[right];
                if(sum > target){
                    right--;
                } else if(sum < target){
                    left++;
                } else{
                    res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    while(left < right && nums[left] == nums[left + 1]) left++;
                    left++;
                    right--;
                }
            }
            }
        }
        return res;
    }
```



## 4、字符串

### 4.1 反转字符串

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

* 思路

  用双指针，一个从头部开始，一个从尾部开始

```java
class Solution {
    public void reverseString(char[] s) {
        int l = 0;
        int r = s.length - 1;
        while (l < r) {
            s[l] ^= s[r];  //构造 a ^ b 的结果，并放在 a 中
            s[r] ^= s[l];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
            s[l] ^= s[r];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
            l++;
            r--;
        }
    }
}
// 第二种方法用temp来交换数值更多人容易理解些
class Solution {
    public void reverseString(char[] s) {
        int l = 0;
        int r = s.length - 1;
        while(l < r){
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l++;
            r--;
        }
    }
}
```



### 4.2 反转字符II

> 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。
>
> - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。



* 思路

  一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。

  其实在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。

  因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。

  **所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章**

```java
public String reverseStr(String s, int k) {
    
        char[] res = s.toCharArray();
    
        for(int i = 0; i < s.length(); i += 2*k){
            if((s.length() - i) >= k && (s.length() - i) < 2*k ){
                reverseString(res,i,i + k - 1);
                break;
            } else if((s.length() - i) < k){
                reverseString(res,i, s.length() - 1);
                break;
            }
            reverseString(res,i, i + k - 1);
        }
        String result = new String(res);
        return result;
    }
    private void reverseString(char[] s, int start, int tail){
        int l = start;
        int r = tail;
        while(l < r){
            char temp = s[l];
            s[l] = s[r];
            s[r] = temp;
            l++;
            r--;
        }
    }
```



### no done 4.3 替换空格

> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
>
> 示例 1： 输入：s = "We are happy."
> 输出："We%20are%20happy."

* 首先扩充数组到每个空格替换后的大小，然后用双指针法，**i指向新长度的末尾，j指向旧长度的末尾。**

 ```java
 public String replaceSpace(String s) {
         char[] res = s.toCharArray();
         int count = 0;
 
         for(int i = 0; i < s.length();i++){
             if(res[i] == ' '){
                 count++;
             }
         }
         char[] last_res = new char[s.length() + 2*count];
         
         for(int i = 0; i < s.length();i++){
             last_res[i] = res[i];
         }
 
         int old_cou = res.length - 1;
         int new_cou = last_res.length - 1;
 
         while(new_cou >= 0){
             if(res[old_cou] != ' '){
                 last_res[new_cou--] = res[old_cou--];
             } else {
                 last_res[new_cou--] = '0';
                 last_res[new_cou--] = '2';
                 last_res[new_cou--] = '%';
                 old_cou--;
             }
         }
         String result = new String(last_res);
 
         return result;
 
     }
 ```





### 4.4 反转字符串中的单词

> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。
>
> **单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。
>
> 返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。
>
> **注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

* **思路**

  可以想一下，我们可以现将整个字符串反转过来，那么单词的顺序是题目要求的倒序了，但是单词本身也是倒过来的，所以再反转一下单词就可以了。所以步骤如下：

  * 移除多余空格
  * 将整个字符串反转
  * 将每个单词反转

```java
public String reverseWords(String s) {
        
        StringBuilder sb = removeSpace(s);

        reverseString(sb,0,sb.length() - 1);

        reverseWord(sb);

        return sb.toString();

    }

    // 消除多余空格
    private StringBuilder removeSpace(String s){
        int start = 0;
        int end = s.length() - 1;

        while(s.charAt(start) == ' ') start++;
        while(s.charAt(end) == ' ') end--;

        StringBuilder sb = new StringBuilder();

        while(start <= end){
            if(s.charAt(start) != ' ' || s.charAt(start - 1) != ' '){
                sb.append(s.charAt(start));
            }
            start++;
        }
        return sb;
    }
    //反转整个字符串
    private void reverseString(StringBuilder sb,int left,int right){
        while(left < right){
            char temp = sb.charAt(left);
            sb.setCharAt(left,sb.charAt(right));
            sb.setCharAt(right,temp);
            left++;
            right--;
        }
    }
    //反转单词
    private void reverseWord(StringBuilder sb){
        int start = 0;
        int end = 0;

        while(end < sb.length() ){
            while(end < sb.length() && sb.charAt(end) != ' '){
                end++;
            }
            reverseString(sb,start,end - 1);
            end++;
            start = end;
        }
    }
```



### 4.5  左旋转字符串

> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"

* **思路**

  这题的思路可以使用**整体反转+局部反转**来实现。

  具体实现的步骤：

  * 反转区间为前n的字串
  * 反转区间为n到末尾的字串
  * 反转整个字符串

```java
public String reverseLeftWords(String s, int n) {
        StringBuilder sb = new StringBuilder(s);

        reverseString(sb, 0, n - 1);

        reverseString(sb, n, sb.length() - 1);

        reverseString(sb, 0, sb.length() - 1);

        return sb.toString();
    }

    private void reverseString(StringBuilder sb,int start,int end){

        while(start < end){
            char temp = sb.charAt(start);
            sb.setCharAt(start,sb.charAt(end));
            sb.setCharAt(end,temp);
            start++;
            end--;
        }
    }
```



### 4.6 ☆实现strStr()

> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

* 思路


#### ☆KMP

> KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**
>
> 所以如何记录已经匹配的文本内容是KMP的重点，也就是next数组肩负的重任。

* **什么是前缀表呢？**

  > 前缀表：记录下标i之前（包括i）的字符串，有多大长度的相同前后缀。

  next数组就是一个前缀表（prefix table）

  **前缀表是用来回退的，它记录了模式串与主串不匹配的时候，模式串应该从哪里开始重新匹配**

  举一个例子：

  要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。

  此时有会出现一个问题**前缀表是如何记录的呢？**

* **最长公共前后缀**

  > 最长公共前后缀也，简单来说就是要存放在next数组里面的内容，它与模式串或其子字串一一对应的。也就是模式串或模式串字串前后缀相等的最大长度。

  下图是一个列子：

  ![](images\KMP精讲8.png)

* **前缀表与next数组**

  next数组是具体实现，而前缀表是KMP理论表，在实际的实现中，都是把前缀表统一减一，之后作为next数组。

  这和具体的实现有关，方便具体实现。

下图是实现图：



![](images\KMP精讲4.gif)





```java
public int strStr(String haystack, String needle) {
        if(needle.length() == 0){
            return 0;
        }
        int[] next = getNext(needle);
        int j = - 1;

        for(int i = 0; i < haystack.length(); i++){
            while(j >= 0 && haystack.charAt(i) != needle.charAt(j + 1)){
                j = next[j];
            }

            if(haystack.charAt(i) == needle.charAt(j + 1)){
                j++;
            }

            if(j == (needle.length() - 1)){
                return (i - needle.length() + 1);
            }
        }
        return -1;
    }

private int[] getNext(String s){

        int[] next = new int[s.length()];
        int j = -1;
        next[0] = j;

        for(int i = 1; i < s.length(); i++) {
            while(j >= 0 && s.charAt(i) != s.charAt(j + 1)){
                j = next[j];
            }

            if(s.charAt(i) == s.charAt(j + 1)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
```



###  4.7 重复的子字符串

> 给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。



```java
public boolean repeatedSubstringPattern(String s) {
        if (s.equals("")) return false;

        int len = s.length();
        // 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了
        s = " " + s;
        char[] chars = s.toCharArray();
        int[] next = new int[len + 1];

        // 构造 next 数组过程，j从0开始(空格)，i从2开始
        for (int i = 2, j = 0; i <= len; i++) {
            // 匹配不成功，j回到前一位置 next 数组所对应的值
            while (j > 0 && chars[i] != chars[j + 1]) j = next[j];
            // 匹配成功，j往后移
            if (chars[i] == chars[j + 1]) j++;
            // 更新 next 数组的值
            next[i] = j;
        }
        // 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值
        if (next[len] > 0 && len % (len - next[len]) == 0) {
            return true;
        }
        return false;
    }
```

## 5、栈与队列（stack and queue）

### 5.1 栈与队列理论基础

> 栈又名堆栈，他是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除操作。

#### 栈

在java中Stack类是栈的实现是，继承了Vector类，所以Stack是线程安全的,即都是同步方法。

Stack类的方法：

| 方法            | 功能                   |
| --------------- | ---------------------- |
| Stack()         | 构造一个空的栈         |
| E push (E e)    | 将e入栈，并返回e       |
| E pop()         | 将栈顶元素出栈并返回   |
| E peek()        | 获取栈顶元素           |
| int size()      | 获取栈中有效元素的个数 |
| boolean empty() | 检测栈是否为空         |

* 用双端队列实现栈

  > Deque表示双端队列。在两端都可以进行插入和删除队列,
  >
  > Deque<E> deque = new LinkedList<>();

  

#### 队列

>  队列中既然可以存储元素，那底层肯定要有能够保存元素的空间，常见的空间类型有两种：顺序结构和链式结构

**一、顺序队列 **

> 像数值一样，队列的存在形式是队列中的元素是连续的

* 顺序队列的实现方式：

  1. 队头不动，队尾动

     >  在删除元素时要将队头删除，然后将后面的元素移动一位，队尾也会随之移动。时间复杂度为O(N)。

  2. 队头动，队尾不动

     > 在删除元素时只需将队头向后移动一位，队尾不动即可。
     >
     > 优点：在出队列时，时间复杂度为O(1)
     >
     > 缺点：因为在元素出队列时知识移动队头，并没有把元素从内存中删除，所以会出现元素把内存耗尽，造成假溢出。

* 循环队列

  > 给定两个指针，分别标记队头和队尾，分别用front和rear
  >
  > 开始时空队列中，front和rear都指向同一位置。
  >
  > 在插入元素时，rear会向后移动；在删除元素时front会向前移动

  **如何判断是否存满呢？**

  1. 少使用一个循环队列的空间

     当front == rear 时，队列为空队列

     当 （rear + 1） % M == front时，即为满队列，M为队列的空间大小

  2. 给一个flag标记

  3. 给一个计数器count

**二、链式队列**

> 就想线性表中的单链表一样，只是说只能从头出从尾进而已



**java中的实现：**

> Queue是java中实现队列的接口它总共有6个方法，我们一般只用其中三个就可以了。Queue的实现类有LinkedList，和PriorityQueue。最常用的是LinkedList。

**六个方法：**

* 压入元素：add()、offer()，返回压入元素
* 弹出元素：remover()、poll()，返回队头被删除的元素
* 获取队头元素：element()、 peek()

|      | 抛出异常  | 返回特殊值                 |
| ---- | --------- | -------------------------- |
| 插入 | add(e)    | offer(e),队列满会返回false |
| 删除 | remove()  | poll()，空队列返回false    |
| 检查 | element() | peek()，空队列返回null     |



#### ☆Deque双端队列集合

> Deque是一个双端队列接口，继承自Queue接口，Deque的实现是LinkedList和ArrayDeque、LinkedBlockingDeque。
>
> 所以Deque既有队列的方法，也有堆栈的方法。



| Queue方法 | 等效Deque方法 |
| --------- | ------------- |
|           |               |
|           |               |
|           |               |
|           |               |
|           |               |
|           |               |



### 5.2 用栈实现队列



```java
class MyQueue {

    Stack<Integer> stackIn;
    Stack<Integer> stackOut;

    /** Initialize your data structure here. */
    public MyQueue() {
        stackIn = new Stack<>(); // 负责进栈
        stackOut = new Stack<>(); // 负责出栈
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        stackIn.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {    
        dumpstackIn();
        return stackOut.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        dumpstackIn();
        return stackOut.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stackIn.isEmpty() && stackOut.isEmpty();
    }

    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中
    private void dumpstackIn(){
        if (!stackOut.isEmpty()) return; 
        while (!stackIn.isEmpty()){
                stackOut.push(stackIn.pop());
        }
    }
}

```



### 5.3 用队列实现栈



```java
Queue<Integer> queue1; // 和栈中保持一样元素的队列
    Queue<Integer> queue2; // 辅助队列

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        queue2.offer(x); // 先放在辅助队列中
        while (!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        Queue<Integer> queueTemp;
        queueTemp = queue1;
        queue1 = queue2;
        queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可
    }
    
    /** Get the top element. */
    public int top() {
        return queue1.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue1.isEmpty();
    }
```



> for循环里面的switch语句可以使用continue语句来跳出一次循环
>
> char类型的引用类型是character



### 5.4 有效括号



但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！



```java
public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            //碰到左括号，就把相应的右括号入栈
            if (ch == '(') {
                deque.push(')');
            }else if (ch == '{') {
                deque.push('}');
            }else if (ch == '[') {
                deque.push(']');
            } else if (deque.isEmpty() || deque.peek() != ch) {
                return false;
            }else {//如果是右括号判断是否和栈顶元素匹配
                deque.pop();
            }
        }
        //最后判断栈中元素是否匹配
        return deque.isEmpty();
    }
```



### 5.5 删除字符串中的所有相邻重复项

> java中添加删除功能最快的集合是ArrayDeque



```java
public String removeDuplicates(String s) {
        //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点
        //参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist
        ArrayDeque<Character> deque = new ArrayDeque<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            if (deque.isEmpty() || deque.peek() != ch) {
                deque.push(ch);
            } else {
                deque.pop();
            }
        }
        String str = "";
        //剩余的元素即为不重复的元素
        while (!deque.isEmpty()) {
            str = deque.pop() + str;
        }
        return str;
    }
```



### 5.6 逆波兰表达式



> 获取字符串数组的长度即元素个数用.length即可



```java
ublic int evalRPN(String[] tokens) {
        Deque<Integer> deque = new ArrayDeque<>();
        int sum = 0;
        for(String s : tokens){
            if(s.equals("+")){
                deque.push(deque.pop() + deque.pop());
            } else if(s.equals("-")){
                deque.push(-deque.pop() + deque.pop());
            } else if(s.equals("*")){
                deque.push(deque.pop() * deque.pop());
            } else if(s.equals("/")){
                int temp1 = deque.pop();
                int temp2 = deque.pop();
                deque.push(temp2 / temp1);
            } else{
                deque.push(Integer.valueOf(s));
            }
        }
        return deque.pop();
    }
```



### 5.7 滑动窗口最大值



```java
class MyQueue {
    Deque<Integer> deque = new LinkedList<>();
    //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出
    //同时判断队列当前是否为空
    void poll(int val) {
        if (!deque.isEmpty() && val == deque.peek()) {
            deque.poll();
        }
    }
    //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出
    //保证队列元素单调递减
    //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2
    void add(int val) {
        while (!deque.isEmpty() && val > deque.getLast()) {
            deque.removeLast();
        }
        deque.add(val);
    }
    //队列队顶元素始终为最大值
    int peek() {
        return deque.peek();
    }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 1) {
            return nums;
        }
        int len = nums.length - k + 1;
        //存放结果元素的数组
        int[] res = new int[len];
        int num = 0;
        //自定义队列
        MyQueue myQueue = new MyQueue();
        //先将前k的元素放入队列
        for (int i = 0; i < k; i++) {
            myQueue.add(nums[i]);
        }
        res[num++] = myQueue.peek();
        for (int i = k; i < nums.length; i++) {
            //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列
            myQueue.poll(nums[i - k]);
            //滑动窗口加入最后面的元素
            myQueue.add(nums[i]);
            //记录对应的最大值
            res[num++] = myQueue.peek();
        }
        return res;
    }
}
```

### 5.8 前k个高频元素

> 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
>
> 示例 1:
>
> - 输入: nums = [1,1,1,2,2,3], k = 2
> - 输出: [1,2]
>
> 示例 2:
>
> - 输入: nums = [1], k = 1
> - 输出: [1]
>
> 提示：
>
> - 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
> - 你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。
> - 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
> - 你可以按任意顺序返回答案。





## 6、二叉树

### 6.1 二叉树基础理论

### 6.2 二叉树的递归遍历

### 6.3 二叉树的迭代遍历

```java
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(){  
    }
    ....
}
//前序遍历
class Solution{
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new ArrayList<>();
        
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.right != null){
                stack.push(node.right);
            }
            if(node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
}
//中序遍历
class Solution{
    public List<Integer> inorderTraversal(TreeNode root){
        List<Integer> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        stack.push(cur);
        while(cur != null || !stack.empty()){
            if(cur != null){
                stack.push(cur);
                cur = cur.left;
            } else{
                cur = stack.pop();
                result.add(cur.val);
                cur = cur.right;
            }
        }
        return result;
    }
}
//后序遍历
class Solution{
    public List<Integer> postorderTraversal(TreeNode root){
        List<Integer> result = new ArrayList<>();
        
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if(node.left != null){
                stack.push(node.left);
            }
            if(node.right != null){
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```



> **DFS(Deep First Search) 深度优先搜索**
>
> **BFS（Breath First Search）广度优先搜索**

### 6.4 二叉树统一的迭代法





```java
//前序
class Solution{
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new ArrayList<>();
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.peek();
            if(node != null){
                stack.pop();
                
                if(node.right != null) stack.push(node.right);
                if(node.left != null) stack.push(node.left);
                stack.push(node);
                stack.push(null);
            } else {
                stack.pop();
                node = stack.pop();
                result.add(node.val);
            }
        }
        return result;
    }
}
//中序
class Solution{
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new ArrayList<>();
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
       	stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.peek();
            if(node != null) {
                stack.pop();
                
                if(node.right != null) stack.push(node.right);
                stack.push(node);
                stack.push(null);
                if(node.left != null) stack.push(node.left);
            } else {
                stack.pop();
                node = stack.pop();
                result.add(node.val);
            }
        }
        return result;
    }
}
//后序
class Solution{
    public List<Integer> preorderTraversal(TreeNode root){
        List<Integer> result = new ArrayList<>();
        if(root == null) {
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        
        stack.push(root);
        while(!stack.empty()){
            TreeNode node = stack.peek();
            if(node != null){
                stack.pop();
                
                stack.push(node);
                stack.push(null);
                if(node.right != null) stack.push(node.right);
                if(node.left != null) stack.pusth(node.left);
            } else {
                stack.pop();
                node = stack.pop();
                result.add(node.val);
            }
        }
        return result;
    }
}
```





### 6.5 二叉树的层序遍历



递归法：

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        
        int deep = 0;
        order(root,result,deep);

        return result;
    }

    public void order(TreeNode cur,List<List<Integer>> result,int deep){
        if(cur == null) return;

        if(result.size() == deep) {
            List<Integer> item = new ArrayList<>();
            result.add(item);
        }

        result.get(deep).add(cur.val);
        order(cur.left,result,deep + 1);
        order(cur.right,result,deep + 1);
    }
}
```

迭代法：

```java
class Solution{
    public List<List<Integer>> levelOrder(TreeNode root){
        List<List<Integer>> result = new ArrayList<>();
        
        if(root == null) return result;
        
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        while(!qu.isEmpty()){
            int size = qu.size();
            List<Integer> item = new ArrayList<>();
            
            for(int i = 0; i < size; i++){
                TreeNode node = qu.poll();
                item.add(node.val);
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
            }
            result.add(item);
        }
        return result;
    }
}
```







```java
class Solution{
    public List<Integer> levelOrfer(TreeNode root){
        List<Integer> result = new ArrayList<>();
        
        if(root == null){
            return result;
        }
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        TreeNode node = root;
        
        while(!qu.isEmpty()){
            result.add(node.val);
            int size = qu.size();
            
            for(int i = 0; i < size; i++){
                TreeNode cur = qu.poll();
                if(cur.left != null) {
                    qu.offer(cur.left);
                    node = cur.left;
                }
                if(cur.right != null) {
                    qu.offer(cur.right);
                    node = cur.right;
                }
            }
        }
        
        return result;
    }
}
```



```java
class Solution{
    public List<Double> levelOrder(TreeNode root){
        List<Double> result = new ArrayList<>();
        
        Queue<TreeNode> qu = new LinkedList<>();
        
        qu.offer(root);
        
        while(!qu.isEmpty()){
            TreeNode node = new TreeNode();
            Double average = 0.0;
            int size = qu.size();
            
            for(int i = 0; i < size; i++){
                node = qu.poll();
                average = average + node.val;
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
            }
            average = average / size;
            result.add(average);
        }
        return result;
    }
}
```



```java
/*
// Definition for a Node(N叉树).
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution{
    public List<List<Integer>> levelOrder(Node root){
        List<List<Integer>> result = new ArrayList<>();
        if(root == null) return result;
        Queue<Node> qu = new LinkedList<>();
        qu.offer(root);
        
        while(!qu.isEmpty()){
            int size = qu.size();
           	List<Integer> item = new ArrayList<>();
            
            for(int i = 0; i < size; i++){
                Node node = qu.poll();
                item.add(node.val);
                List<Node> chil = node.children;
                for(int j = 0; j < chil.size(); j++){
                    Node cur = chil.get(j);
                    qu.offer(cur);
                }
            }
            result.add(item);
        }
        return result;
    }
}
```



```java
class Solution{
    public List<Integer> levelOrder(TreeNode root){
        List<Integer> result = new ArrayList<>();
        if(root == null) return result;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        while(!qu.isEmpty()){
            int max = qu.peek().val;
            int size = qu.size();
            
            for(int i = 0; i < size; i++){
                TreeNode node = qu.poll();
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
                
                if(max < node.val){
                    max = node.val;
                }
            }
            result.add(max);
        }
        return result;
    }
}
```



```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/
class Solution{
    public Node connect(Node root){
        Queue<Node> qu = new LinkedList<>();
        if(root != null) qu.offer(root);
        while(!qu.isEmpty()){
            int size = qu.size();
            
            Node cur = qu.poll();
            if(cur.left != null) qu.offer(cur.left);
            if(cur.right != null) qu.offer(cur.right);
            
            for(int i = 1; i < size; i++){
                Node node = qu.poll();
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
                
                cur.next = node;
                cur = node;
            }
        }
        
        return root; 
    }
}
```



```java
class Solution{
    public int maDepth(TreeNode root){
        Queue<TreeNode> qu = new LinkedList<>();
        if(root != null) qu.offer(root);
        int max = 0;
      	while(!qu.isEmpty()){
            int size = qu.size();
            
            for(int i =0 ; i < size; i++){
                TreeNode node = qu.poll();
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
            }
            
            max++;
        }
        return max;
    }
}
```





```java
class Solution{
    public int minDepth(TreeNode root) {
        Queue<TreeNode> qu = new LinkedList<>();
        if(root != null) qu.offer(root);
        int min = 0;
        while(!qu.isEmpty()){
            min++;
            int size = qu.size();
            
            for(int i = 0 ; i < size; i++){
                TreeNode node = qu.poll();
                if(node.left == null && node.right == null) return min;
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
            }
            
        }
        return min;
    } 
}
```



### 6.6 翻转二叉树



```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        if(root == null) return root;
        stack.push(root);
        while(!stack.empty()){
            TreeNode cur = stack.pop();
            if(cur != null){
                
                if(cur.right != null) stack.push(cur.right);
                if(cur.left != null) stack.push(cur.left);
                stack.push(cur);
                stack.push(null);
                
            } else {
                cur = stack.pop();
                TreeNode node = cur.left;
                cur.left = cur.right;
                cur.right = node;
            }
        }
        return root;
    }
    
}
```

### 6.7 对称二叉树



**递归法：**

三部曲：

**（1）确定递归函数的参数和返回值**

**（2）确定终止条件**

**（3）确认单层递归逻辑**

```java
class Solution{
    public boolean compare(TreeNode left, TreeNode right){
        
        if(left == null && right == null) return true;
        else if(left == null && right != null) return false;
        else if(left != null && right == null)  return false;
        else if(left.val != right.val) return false;
        
        boolean outside = compare(left.left, right.right);
        boolean inside = compare(left.right, right.left);
        
        boolean isSame = outside && inside;
        
        return isSame;
    }
    public boolean isSymmetric(TreeNode root){
        if(root == null) return true;
        
        return compare(root.left, root.right);
    }
}
```

**迭代法(队列)：**

```java
class Solution{
    public boolean isSymmetric(TreeNode root){
        if(root == null) reutn true;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root.left);
        qu.offer(root.right);
        while(!qu.isEmpty()){
            TreeNode node1 = qu.poll();
            TreeNode node2 = qu.poll();
            if(node1 == null && node2 == null) continue;
            
            if(node1 == null && node2 != null) return false;
            
            if(node1 != null && node2 == null) return false;
            
            if(node1.val != node2.val) return false;
            
            qu.offer(node1.left);
            qu.offer(node2.right);
            qu.offer(node1.right);
            qu.offer(node2.left);
            
        }
        return true;
    }
}
```

**另一个树的子树:**

```java
class Solution{
    public boolean isSubtree(TreeNode root, TreeNode subRoot){
        if(subRoot == null) return true;
        if(root == null) return false;//这时subRoot一定不为null
        return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot) || isSameTree(root,subRoot);
    }
    
    public boolean isSameTree(TreeNode tree1, TreeNode tree2){
        if(tree1 == null && tree2 == null) return true;
        if(tree1 == null || tree2 == null) return false;
        if(tree1.val != tree2.val) return false;
        
        return isSameTree(tree1.left, tree2.left) && isSameTree(tree1.right,tree2.right);
    }
}
```

### 6.8 完全二叉树的节点个数

> 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点

完全二叉树只有两种情况，

情况一：就是满二叉树，情况二：最后一层叶子节点没有满

对于情况一，可以直接用2^数深度 - 1来计算，注意这里根节点深度为1

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后根据情况一来计算。

**那么如何判断一个树是不是满二叉树呢？**

**在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树**



递归：

```java
class Solution{
    public int countNodes(TreeNode root){
        if(root == null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0;
        int rightDepth = 0;//这里初始为0是方便下面的指数计算
        while(left != null) {
            left = left.left;
            leftDepth++;
        }
        while(right != null){
            right = right.right;
            rightDepth++;
        }
        if(leftDepth == rightDepth){
            return (2 << leftDepth) - 1;
            //注意（2<<1） 相当于2^2,所以leftDepth初始为0
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

递归精简版：

```java
class Solution {
    // 通用递归解法
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

**6.9 平衡二叉树**

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

* 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
* 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

![](images\屏幕截图 2023-10-17 144544.png)



递归法：

```java
class Solution{
    public boolean isBalanced(TreeNode root){
        return getHeight(root) == -1 ? false : true;
    } 
    
    public int getHeight(TreeNode node){
        if(node == null){
            return 0;
        }
        int leftHeight = getHeight(node.left);
        if(leftHeight == - 1) {
            return -1;
        }
        int rightHeight = getHeight(node.right);
        if(rightHeight == -1) {
            return -1;
        }
        int result;
        if( Math.abs(leftHeight - rightHeight) > 1){
            result = -1;
        } else {
            result = 1 + Math.max(leftHeight, rightHeight);
        }
        return result;
    }
}
```

迭代法：

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root!= null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            TreeNode inNode = stack.peek();
            // 右结点为null或已经遍历过
            if (inNode.right == null || inNode.right == pre) {
                // 比较左右子树的高度差，输出
                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) > 1) {
                    return false;
                }
                stack.pop();
                pre = inNode;
                root = null;// 当前结点下，没有要遍历的结点了
            } else {
                root = inNode.right;// 右结点还没遍历，遍历右结点
            }
        }
        return true;
    }
    /**
     * 层序遍历，求结点的高度
     */
    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```



### 6. 9 ☆二叉树的所有路径

> 给定一个二叉树，返回所有从根节点到叶子节点的路径。
>
> 说明: 叶子节点是指没有子节点的节点



**思路：**这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。

在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。

![](images\屏幕截图 2023-10-17 154353.png)



递归：

三部曲：

**（1）递归函数的参数与返回值**

**（2）确定递归终止条件**

**（3）确定单层递归逻辑**

​	**回溯和递归是一一对应的，有一个递归，就要有一个回溯**，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。

​	**所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！**

```java
class Solution{
    public List<String> binaryTreePaths(TreeNode root){
        List<String> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        
        traversal(root, path, result);
        
        return result;
    }
    
    public void traversal(TreeNode node,List<Integer> path, List<String> result){
        path.add(node.val);
        
        if(node.left == null && node.right == null) {    
            StringBuilder sb = new StringBuilder();
            sb.append(path.get(0));
            for(int i = 1 ; i < path.size(); i++){
                sb.append("->").append(path.get(i));
            }
            result.add(sb.toString());
            return;
        }
        
        if(node.left != null) {
            traversal(node.left, path, result);
            path.remove(path.size() - 1);
        }
        if(node.right != null) {
            traversal(node.right, path, result);
            path.remove(path.size() - 1);
        }
    }
}
```

隐式回溯：

```java
class Solution {

    List<String> result = new ArrayList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        deal(root, "");
        return result;
    }

    public void deal(TreeNode node, String s) {
        if (node == null)
            return;
        if (node.left == null && node.right == null) {
            result.add(new StringBuilder(s).append(node.val).toString());
            return;
        }
        String tmp = new StringBuilder(s).append(node.val).append("->").toString();
        deal(node.left, tmp);
        deal(node.right, tmp);
    }
}
```

使用`List<Integer> path`  和`String s`来存储路径，两者解决方式不同，path因为是统一的传入参数，所以里面的值在每个路劲中都在改变，所以每一次递归都要回溯一次；而每次传入的s不同，可以看成每次传入参数前都会回溯，即隐式回溯。



迭代法：

```java
class Solution{
    public List<String> binaryTreePaths(TreeNode root){
        List<String> result = new ArrayList<>();
        if(root == null) return result;
        Stack<Object> stack = new Stack<>();
        
        stack.push(root);
        stack.push(root.val + "");
        while(!stack.isEmpty()){
            String path = stack.pop();
            TreeNode node = stack.pop();
            
            if(node.left == null && node.right == null){
                result.add(path);
            }
            
            if(node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            if(node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```





### 6.10 左叶子之和





递归：

```java
class Solution{
    public int sumOfLeftLeaves(TreeNode root){
        if(root == null) return 0;
        
        return sumOfLeft(root);
    }
    
    public int sumOfLeft(TreeNode node) {     
        if(node == null){
            return 0;
        }
        int leftValue = 0;
        if(node.left != null && node.left.left == null && node.left.right == null){
            leftValue =  node.left.val;
        }
        
        return leftValue + sumOfLeft(node.left) + sumOfLeft(node.right);
    }
}
```





迭代：

```java
class Solution{
    public int sumOfLeftLeaves(TreeNode root){
        if(root == null) return 0;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        int sum = 0;
        
        while(!stack.isEmpty()){
            TreeNode node = stack.peek();
            if(node != null) {
                stack.pop();
                
                if(node.right != null) stack.push(node.right);
                if(node.left != null) stack.push(node.left);
                stack.push(node);
                stack.push(null);
                
            } else {
                stack.pop();
                node = stack.pop();
                
                if(node.left != null && node.left.left == null && node.left.right == null){
                    sum += node.left.val;
                }
            }
        }
        
        return sum;
    }
}
```



### 6.11 找左下角的值



递归：

```java
class Solution{
    
    private int maxDepth = 0;
    
    private int value;
        
    public int findBottomLeftValue(TreeNode root){
        if(root == null) return 0;
        find(root,1);
        return value;
    }
    
    public void find(TreeNode node, int depth){
        if(node == null) return;
        
        if(node.left == null && node.right == null){
            if(depth > maxDepth) {
                value = node.val;
                maxDepth = depth;
            }
        }
        find(node.left, depth + 1);
        find(node.right, depth + 1);
        return;
    }
}
```



层序遍历：

```java
class Solution{
    public int findBottomLeftValue(TreeNode root){
        if(root == null) return 0;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        int result;
        while(!qu.empty()){
            int size = qu.size();
            TreeNode node = new TreeNode();
          
            for(int i = 0; i < size; i++){
                node = qu.poll();
                if(i = 0) result = node.val;
                if(node.left != null) qu.offer(node.left);
                if(node.right != null) qu.offer(node.right);
            }
        }
        return result;
    }
}
```

### 6.12 路径总和

递归：

```java
class Solution{
    public boolean hasPathSum(TreeNode root, int targetSum){
        if(root == null) return false;
        
        return pathSum(root,targetSum);
    }
    
    public boolean pathSum(TreeNode node,int target){
        if(node == null) return false;
        
        int sum = target - node.val;
        
        if(sum == 0 && node.left == null && node.right == null){
            return true;
        }
        
        return pathSum(node.left, sum) || pathSum(node.right, sum);
    }
}
```

迭代：

```java
class Solution{
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        Stack<Object> stack = new Stack<>();
        //在栈中存储目标路径总和与到该节点之前的总和
        stack.push(targetSum);
        stack.push(root);
        while(!stack.empty()) {
            TreeNode node = (TreeNode)stack.pop();
            int target = (int)stack.pop();
            int sum = target - node.val; 
            
            if(sum == 0 && node.left == null && node.right == null){
                return true;
            }
            
            if(node.left != null) {
                stack.push(sum);
                stack.push(node.left);
            }
            if(node.right != null) {
                stack.push(sum);
                stack.push(node.right);
            }
        }
        return false;
    }
}
```



### 6.13 从中序与后序遍历序列构造二叉树

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
    var f func(ins , pos , len int) *TreeNode
    // 取头去尾
    f = func (ins , pos , len int) *TreeNode{
        if len == 0 {
            return nil
        }
        tree := &TreeNode{}
        tree.Val = postorder[pos + len - 1]
        if len == 1 {
            return tree
        }
        i := 0
        for i < len && tree.Val != inorder[i + ins] {
            i++
        }
        tree.Left = f(ins, pos, i)
        tree.Right = f(ins + i + 1, pos + i, len - 1 - i)
        return tree
    }
    return f(0,0,len(inorder))
}
```



递归：

```java
class Solution{
    Map<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i], i);
        }
        return build(inorder,0,inorder.length,postorder,0,postorder.length);
      	
    }
    public TreeNode build(int[] inorder, int inbegin, int inend,int[] postorder,int postbegin, postend){
        if(inbegin >= inend || postbegin >= postend) return null;        
        TreeNode root = new TreeNode();
        root.val = posorder[postend - 1];
        
        int orderindex = map.get(root.val);
        //记录长度
        int lenOfLeft = orderindex - inbegin;
        
        root.left = build(inorder, inbegin,orderindex,postoder,postbegin,postbegin + lenOfLeft);
        root.right = build(inorder,orderindex+1,inend,postorder,postbegin + lenOfLeft,postend-1);
        return root;          
    }
}
```



☆迭代：

* 思路

  例子：

  ```txt
          3
         / \
        9  20
       / \   \
      15 10   7
             / \
            5   8
                 \
                  4
  
  inorder = [15, 9, 10, 3, 20, 5, 7, 8, 4]
  postorder = [15, 10, 9, 5, 4, 8, 7, 20, 3]
  ```

​		用一个栈`stack`来维护 [ 还没有考虑过左节点的右节点或根节点 ]，也就是说栈中的元素有可能有左孩子的。同时，我们用一个指针 `index`指向中序遍历的某个位置，这个指针对应的节点是 [ 当前节点不断往右走达到的最终节点 ]。

* 我们初始时先将后序遍历的尾结点即根节点放入 `stack` 中即 `3`节点 ，让`index`指向中序遍历的尾结点 `4`。
* 我们遍历到 `20`，它一定是 **栈顶元素**`3` 节点的右儿子。首先很容易知道它一定是 `3` 节点的子节点，然后使用反证法来证明为，如果它是左儿子，说明 `3` 和`20`两节点之间不存在其它节点， `3` 没有右儿子，那么`index` 指向的节点一定是 `3`，但是实际指向的是 `4`，说明 `20` 一定是右儿子。将其 作为 `3` 的右儿子，并入栈。
  - `stack = [3, 20]`
  - `index -> inorder[8] = 4`
* 同理，依次遍历 `7`,`8`和`4`。依次入栈
  - `stack = [3, 20, 7, 8, 4]`
  - `index -> inorder[8] = 4`

* 我们遍历到 `5`节点时，栈顶元素是 `4`节点与 `index` 指向的节点相同，说明它是某一个节点的左儿子。那么如何找到这个节点呢？

  栈中的元素前一个一定是后一个的某个祖先，反中序遍历顺序与栈中出栈顺序相同。我们将 `index` 减 `1`并弹出栈顶节点，直到 `index` 对应的元素不等于栈顶单元。我们弹出的最后一个节点 `x` 就是目标节点。**这是因为 `5` 出现在了 `x` 与 `x` 在栈中的下一个节点的反向中序遍历之间**

  回到我们的例子，我们会依次从栈顶弹出 4，8 和 7，并且将 index 向左移动了三次。我们将 5 作为最后弹出的节点 7 的左儿子，并将 5 入栈。

  * `stack = [3, 20, 5]`
  * `index -> inorder[5] = 5`

后面同理可得。

代码实现：

```java
class Solution{
    public TreeNode buildTree(int[] inorder, int[] postorder){
        if(postorder == null || postorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(postorder[postorder.length - 1]);
        Deque<TreeNode> stack = new LinkedList<>();
        int index = inorder.length - 1;
        stack.push(root);
        for(int i = postorder.length - 2; i >= 0; i--){
            TreeNode node = new TreeNode(postorder[i]);
            if(stack.peek().val != inorder[index]){
            	TreeNode parent = stack.peek();
                parent.right = node;
                stack.push(node);
            } else {
                TreeNode cur = new TreeNode();
                while(!stack.isEmpty() && stack.peek().val == inorder[index]){
                    cur = stack.pop();
                	index--;
                };
                cur.left = node;
                stack.push(node);
            }
        }
        return root;
    }
}
```



### 6.14 最大二叉树



递归：

```java
class Solution{
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length == 0) return null;
        //左闭右开
        return constructTree(nums, 0 , nums.length);
        
    }
    
    public TreeNode constructTree(int[] nums, int start, int end){       
        if(end  - start < 1) {
            return null;
        }
        if(end - start == 1) {
            return new TreeNode(nums[start]);
        }
        //获取最大的元素以及索引
        int max = nums[start];
        int index = start;
        for(int i = start + 1 ; i < end; i++){
             if(nums[i] > max) {
                 max = nums[i];
                 index = i;
             }
        }
        TreeNode root = new TreeNode(max);
        root.left = constructTree(nums,start,index);
        root.right = constructTree(nums,index + 1,end);
        return root;
    }
}
```

### 6.15 合并二叉树





递归：

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2){
        
        if(root1 == null) return root2;
        if(root2 == null) return root1;
        
        root1.val += root2.val;
        
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    }
}
```

迭代：

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if (root2 ==null) return root1;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root1);
        qu.offer(root2);
        while(!qu.isEmpty()){
        	TreeNode node1 = qu.poll();
        	TreeNode node2 = qu.poll();
            node1.val += node2.val;

            if(node1.left != null && node2.left != null) {
                qu.offer(node1.left);
                qu.offer(node2.left);
            } 
            if(node1.right != null && node2.right != null) {
                qu.offer(node1.right);
                qu.offer(node2.right);
            }
            if(node1.left == null && node2.left != null) {
                node1.left = node2.left;
            }
            if(node1.right == null && node2.right != null) {
                node1.right = node2.right;
            }
        }
        return root1;
    }
}
```





### 6.16 二叉搜索树中的搜索



二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树



迭代法：

```java
class Solution{
    public TreeNode searchBST(TreeNode root, int val){
        if(root == null) return null;
        
        Stack<TreeNode> stack = new Stack<>();
        
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            
            if(node.val == val){
                return node;
            } else if(node.val > val){
                if(node.left != null) stack.push(node.left);
            } else if(node.val < val){
                if(node.right != null) stack.push(node.right);
            }
        }
        
        return null;
    }
}
```



### 6.17 验证搜索二叉树

* 思路

  要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。

  有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了**

递归：

```java
class Solution{
    TreeNode pre;
    
    public boolean isValidBST(TreeNode root){

        if(root == null) return true;
            
        boolean left = isValidBST(root.left);
        
        if(pre != null && pre.val >= root.val){
            return false;
        }
        pre = root;
        
        boolean right = isValidBST(root.right);
        
        return left && right;
        
    }
}
```

迭代：

```java
class Solution{
    public boolean isValidBST(TreeNode root){
        if(root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        int current = 0;
        int count = 0;
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node != null) {
                if(node.right != null )stack.push(node.right);
                stack.push(node);
                stack.push(null);
                if(node.left != null) stack.push(node.left);
            } else {
                node = stack.pop();
                if(count == 0) {
                    current = node.val;
                    count++;
                } else{
                    if(node.val <= current){
                    	return false;
                	}
                	current = node.val;
                }
            }
        }
        return true;
    }
}
```



### 6.18 二叉搜索树的最小绝对差值

那么二叉搜索树采用中序遍历，其实就是一个有序数组。

**在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。**

最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。

递归：

```java
class Solution{
    TreeNode result = null;
    TreeNode pre = null;
    public int getMinimumDifference(TreeNode root){
        getMini(root);
        return result.val;
    }

    public void getMini(TreeNode root){
        int diff;
        if(root.left != null)getMini(root.left);

        if(pre == null){
            pre = new TreeNode();
        } else {
            diff = Math.abs(root.val - pre.val);
            if(result == null){
                result = new TreeNode(diff);
            } else if(diff < result.val){
                result.val = diff;
            }
        }
        pre = root;
        if(root.right != null)getMini(root.right);
    }
}
```

迭代：

 ```java
 class Solution{
     public int getMinimumDifference(TreeNode root){
                
         Stack<TreeNode> stack = new Stack<>();
         stack.push(root);
         TreeNode result = null;
         TreeNode pre = null;
         
         while(!stack.isEmpty()){
             TreeNode node = stack.pop();
             if(node != null) {
                 if(node.right != null) stack.push(node.right);
                 stack.push(node);
                 stack.push(null);
                 if(node.left != null) stack.push(node.left);
             } else {
                 node = stack.pop();
                 if(pre == null){
                     pre = new TreeNode();
                 } else {
                     int diff = Math.abs(node.val - pre.val);
                     if(result == null){
                         result = new TreeNode(diff);
                     } else if(diff < result.val) {
                         result.val = diff;
                     }
                 }
                 pre = node;
                 }
             }
             return result.val;
         }
         
     }
 ```



### 6.19 二叉搜索树中的众数



递归：

```java
class Solution{
    ArrayList<Integer> resList = new ArrayList<>();
    int maxCount;
    int count;
    TreeNode pre;
    public int[] findMode(TreeNode root){
        find(root);
        int[] result = new int[resList.size()];
        for(int i = 0; i < resList.size(); i++){
            result[i] = resList.get(i);
        }
        return result;
    }
    public void find(TreeNode node){
        if(node == null) return;
        
        find(node.left);    
        //处理第一个节点，初始化
        if(pre == null) {
            maxCount = 1;
            count = 1;
        } else {//处理后续节点
            if(pre.val == node.val){
                count++;
            } else {
                count = 1;
            }
        }
        if(count == maxCount) {
            resList.add(node.val);
        } else if(count > maxCount){
            maxCount = count;
            resList.clear();
            resList.add(node.val);            
        }
        pre = node;
        find(node.right);
    }
}
```

迭代：

```java
class Solution{
    public int[] findMode(TreeNode root){
        Stack<TreeNode> stack = new Stack<>();
        Map<Integer,Integer> map = new HashMap<>();
        List<Integer> list = new ArrayList<>();
        stack.push(root);
        int max = 1;
        while(!stack.isEmpty()){
            TreeNode node = stack.pop(); 
            if(node.right != null) stack.push(node.right);
            if(node.left != null) stack.push(node.left);
            if(!map.containsKey(node.val)){
                map.put(node.val,1);
            } else {
                int time = map.get(node.val);
                map.put(node.val,time + 1); 
                if(time + 1 > max) max = time + 1;
            }
        }
        
        for(Map.Entry<Integer,Integer> entry : map.entrySet()){
           if(entry.getValue() == max){
               list.add(entry.getKey());
           }
        }
        int[] result = new int[list.size()];

        for(int j = 0; j < list.size(); j++){
            result[j] = list.get(j);
        }
        return result;
    }
}
```

### 6.20 二叉树的最近公共祖先

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

这题要用到回溯，后序遍历

递归：

```java
class Solution {
    
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == q || root == p || root == null) return root;
        
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        
        if(left != null && right != null){
            return root;
        } else if( left == null && right != null) {
            return right;
        } else if (left != null && right == null){
            return left;
        } else {
            return null;
        }
    }
}
```



### 6.21 二叉搜索数最近公共祖先



* #### 思路

  搜索二叉树是有序的，所以在不存在重复节点的搜索二叉树时，当中间结点在 [p,q] 区间内时，这个中间结点一定是最近公共祖先。

递归：

```java
class Solution{
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;
        
        if(root.val >= p.val && root.val <= q.val || root.val <= p.val && root.val >= q.val){
            return root;
        } else if(root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if(root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right,p,q);
        }
        return null;
    }
    
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
}
```



迭代：

```java
class Solution{
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){
        if(root == null) return null;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node.val >= p.val && node.val <= q.val || node.val <= p.val && node.val >= q.val){
                return node;
            } else if(node.val > p.val && node.val > q.val) {
                if(node.left != null) stack.push(node.left);
            } else {
                if(node.right != null) stack.push(node.right);
            }
        }
        return null;
    }
    
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (true) {
            if (root.val > p.val && root.val > q.val) {
                root = root.left;
            } else if (root.val < p.val && root.val < q.val) {
                root = root.right;
            } else {
                break;
            }
        }
        return root;
    }
}
```



### 6.22 二叉树搜索树中的插入操作

只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了

递归：

```java
class Solution{
    public TreeNode insertIntoBST(TreeNode root, int val){
        
        if(root == null) {
            root = new TreeNode(val);
            return root;
        } 
        if(root.val > val){
            root.left = insertIntoBST(root.left,val);
        } else {
            root.right = insertIntoBST(root.right,val);
        }
        return root;
    }
}
```



### 6.23 删除二叉搜索树中的节点



* #### 思路

  处理节点时分情况讨论，

  * 第一种情况，没有找到目标节点，遍历到null，直接返回

  * 第二种情况，找到目标节点，并且目标节点没有左右孩子，即是叶子节点，直接删除，返回NULL为根节点。
  * 第三种情况，目标节点，只有左孩子，没有右孩子（或者只有右孩子，没有左孩子）；直接返回左孩子（或右孩子）作为根节点。
  * 第四种情况，目标节点，左孩子、右孩子都存在；将右孩子作为根节点，然后将左孩子作为根节点的最左边的叶子节点的左孩子，然后返回根节点。

递归：

```java
class Solution{
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null){
            return root;
        } else if(root.val > key){
            root.left = deleteNode(root.left, key);
        } else if(root.val < key){
            root.right = deleteNode(root.right, key);
        } else {
            if(root.left == null && root.right == null) {
                return null;
            } else if(root.left != null && root.right == null){
                return root.left;
            } else if(root.left == null && root.right != null){
                return root.right;
            } else {
                TreeNode cur = root.right;
                while(cur.left != null){
                    cur = cur.left;
                }
                cur.left = root.left;
                return root.right;
            }
        }
        return root;
    }
}
```

迭代：

```java
class Solution{
    public TreeNode deleteNode(TreeNode root, int key) {
        
        TreeNode cur = root;
        int flag = 0;
        TreeNode pre = new TreeNode();
        while(true){
            if(cur == null){
                return root;
            } else if(cur.val > key){
                pre = cur;
                cur = cur.left;
                flag = 1;
                continue;
            } else if(cur.val < key){
                pre = cur;
                cur = cur.right;
                flag = 2;
                continue;
            } else {
                if(cur.left == null && cur.right == null) {
                      if(flag == 1) {
                          pre.left = null;
                      } else if(flag == 2) {
                          pre.right = null;
                      } else{
                          root = null;
                      }
                    return root;
                } else if(cur.left != null && cur.right == null) {
                    if(flag == 1) {
                          pre.left = cur.left;
                      } else if(flag == 2) {
                          pre.right = cur.left;
                      } else {
                          root = cur.left;
                      }
                    return root;
                } else if(cur.left == null && cur.right != null) {
                    if(flag == 1) {
                          pre.left = cur.right;
                      } else if(flag == 2) {
                          pre.right = cur.right;
                      } else{
                          root = cur.right;
                      }
                    return root;
                } else {
                    TreeNode node = cur.right;
                    while(node.left != null){
                        node = node.left;
                    }
                	node.left = cur.left;
                    if(flag == 1) {
                          pre.left = cur.right;
                      } else if(flag == 2) {
                          pre.right = cur.right;
                      } else{
                          root = cur.right;
                      }
                	return root;
                }
            }
        }
    }
}
```



### 6.24 修剪二叉搜索树









* #### 思路



递归：

```java
class Solution{
    public TreeNode trimBST(TreeNode root, int low, int high){
        // 遇到范围外的节点直接返回null
        if(root == null) return null;
        
        if(root.val < low){
            return trimBST(root.right, low, high);
        }
        if(root.val > high){
            return trimBST(root.left, low, high);
        }
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        
        return root;
    }
}
```

**☆迭代**：

```java
class Solution {
    //iteration
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null)
            return null;
        while(root != null && (root.val < low || root.val > high)){
            if(root.val < low)
                root = root.right;
            else
                root = root.left;
        }
        
        TreeNode curr = root;
        
        //deal with root's left sub-tree, and deal with the value smaller than low.
        while(curr != null){
            while(curr.left != null && curr.left.val < low){
                curr.left = curr.left.right;
            }
            curr = curr.left;
        }
        //go back to root;
        curr = root;

        //deal with root's righg sub-tree, and deal with the value bigger than high.
        while(curr != null){
            while(curr.right != null && curr.right.val > high){
                curr.right = curr.right.left;
            }
            curr = curr.right;
        }
        return root;
    }
}
```









### 6.24 把有序数组转化为二叉搜索树

> 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
>
> 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

* 思路：二叉搜索树的中序遍历是有序的

迭代法：

```java
class Solution{
    public TreeNode sortedArrayToBST(int[] nums) {
        int size = nums.length;
        TreeNode root = getRootTreeNode(nums,0,size - 1);
        return root;
    }
    
    public TreeNode getRootTreeNode(int[] nums, int start, int end){
        TreeNode root = new TreeNode();
        if(end - start < 0){
            return null;
        }
        if(start - end == 0){
            root.val = nums[start];
            return root;
        }
        int rootIndex = (end - start)/2 + start; // 0 
        root.val = nums[rootIndex];
        root.left = getRootTreeNode(nums,start,rootIndex - 1);
        root.right = getRootTreeNode(nums,rootIndex + 1  ,end);
        return root;
    }
}
```

非递归：

```java
class Solution {
	public TreeNode sortedArrayToBST(int[] nums) {
		if (nums.length == 0) return null;

		//根节点初始化
		TreeNode root = new TreeNode(-1);
		Queue<TreeNode> nodeQueue = new LinkedList<>();
		Queue<Integer> leftQueue = new LinkedList<>();
		Queue<Integer> rightQueue = new LinkedList<>();

		// 根节点入队列
		nodeQueue.offer(root);
		// 0为左区间下标初始位置
		leftQueue.offer(0);
		// nums.size() - 1为右区间下标初始位置
		rightQueue.offer(nums.length - 1);

		while (!nodeQueue.isEmpty()) {
			TreeNode currNode = nodeQueue.poll();
			int left = leftQueue.poll();
			int right = rightQueue.poll();
			int mid = left + ((right - left) >> 1);

			// 将mid对应的元素给中间节点
			currNode.val = nums[mid];

			// 处理左区间
			if (left <= mid - 1) {
				currNode.left = new TreeNode(-1);
				nodeQueue.offer(currNode.left);
				leftQueue.offer(left);
				rightQueue.offer(mid - 1);
			}

			// 处理右区间
			if (right >= mid + 1) {
				currNode.right = new TreeNode(-1);
				nodeQueue.offer(currNode.right);
				leftQueue.offer(mid + 1);
				rightQueue.offer(right);
			}
		}
		return root;
	}
}
```



### 6.25 把二叉搜索树转换为累加树

> 给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。
>
> 提醒一下，二叉搜索树满足下列约束条件：
>
> - 节点的左子树仅包含键 **小于** 节点键的节点。
> - 节点的右子树仅包含键 **大于** 节点键的节点。
> - 左右子树也必须是二叉搜索树。

* 思路

  **其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。**

  **从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了**

**递归Recursion**：

```java
class Solution {
    private int sum;
    
    public TreeNode convertBST(TreeNode root) {
        if(root == null) return null;
        convertBST(root.right);
		root.val = root.val + sum;
        sum = root.val;
        convertBST(root.left);
        return root;
    }
    
}
```

**迭代iterate：**

```java
class Solution{
    private int sum; 
    public TreeNode convertBST(TreeNode root){
        if(root == null) return null;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node != null){
                if(node.left != null) stack.push(node.left);
                stack.push(node);
                stack.push(null);
                if(node.right != null) stack.push(node.right);
            } else{
                TreeNode cur = stack.pop();
                cur.val = cur.val + sum;
                sum = cur.val;
            }
        }
        return root;
    }
}
```



## 7、回溯算法

> 回溯法也可以叫做回溯搜索法，它是一种搜索方式。
>
> 回溯是递归的副产品，只要有递归，就会有回溯。

* ### 回溯的效率

  虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。

* ### 回溯解决的问题

  * 组合问题：N个数里面按一定规则找出k个数的集合（组合不分顺序）
  * 切割问题：一个字符串按一定规律有几种切割方式
  * 子集问题：一个N个数的集合里有多少符合条件的子集
  * 排列问题：N个数按一定规则全排列，有几种排列方式
  * 棋盘问题：N皇后，解数独等等

* ### 如何理解回溯法

  回溯法解决问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。

* ### 回溯法模板

  ```c
  void backtracking(参数) {
      if (终止条件) {
          存放结果;
          return;
      }
  
      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
          处理节点;
          backtracking(路径，选择列表); // 递归
          回溯，撤销处理结果
      }
  }
  ```

### 7.1 组合问题

> 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
>
> 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]

这是回溯算法的经典题目，因为是组合，所以我们要从1开始遍历，和后面的数组合，后面的数同理组合。所以就需要一个变量`startIndex`来记录数的位置。

![](images\屏幕截图 2024-01-12 232859.png)

* #### 未剪枝优化

  ```java
  class Solution{
      List<List<Integer>> resList = new ArrayList<>();
      List<Integer> item = new LinkedList<>();
      public List<List<Integer>> combine(int n , int k){
          combineRec(n, k, 1);
          return resList;
      }
      
      public void combineRec(int n, int k, int startIndex){
          if(item.size() == k){
              resList.add(new ArrayList<>(item));
              return;
          }
          for(int i = startIndex; i <= n; i++){
              item.add(i);
              combineRec(n, k, i+1);
              item.removeLast();
          }
      }
  }
  ```

* #### 剪枝优化后

  对本题来说，如果本身的数组长度要小于等于k的值，就没有必要继续遍历，所以可以对遍历树进行剪枝优化。

  * `startIndex`：当前节点开始位置
  * `k - item.size()`:还需要的节点数
  * `n - startIndex + 1`：还剩余的数的个数(+1是因为索引本身位置的数也没有用到)

  我们需要的是判断**需要的节点数**是否等于或小于**还剩余的数个数**，又因为我们开始遍历的索引是`startIndex`,所以要满足`startIndex < n - (k - item.size()) + 1  `

  所以我们开始遍历的数**至多**为` n - (k - item.size()) + 1`;

  ```java
  class Solution{
      List<List<Integer>> resList = new ArrayList<>();
      List<Integer> item = new LinkedList<>();
      public List<List<Integer>> combine(int n , int k){
          combineRec(n, k, 1);
          return resList;
      }
      
      public void combineRec(int n, int k, int startIndex){
          if(item.size() == k){
              resList.add(new ArrayList<>(item));
              return;
          }
          for(int i = startIndex; i <= n - (k - item.size()) + 1; i++){
              item.add(i);
              combineRec(n, k, i+1);
              item.removeLast();
          }
      }
  }
  ```


### 7.2 组合问题III

> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：
>
> - 只使用数字1到9
> - 每个数字 **最多使用一次** 
>
> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
> **示例 1:**
>
> ```
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> 解释:
> 1 + 2 + 4 = 7
> 没有其他符合的组合了
> ```

```java
class Solution {
	List<List<Integer>> result = new ArrayList<>();
	LinkedList<Integer> path = new LinkedList<>();

	public List<List<Integer>> combinationSum3(int k, int n) {
		backTracking(n, k, 1, 0);
		return result;
	}

	private void backTracking(int targetSum, int k, int startIndex, int sum) {
		// 减枝
		if (sum > targetSum) {
			return;
		}

		if (path.size() == k) {
			if (sum == targetSum) result.add(new ArrayList<>(path));
			return;
		}

		// 减枝 9 - (k - path.size()) + 1
		for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
			path.add(i);
			sum += i;
			backTracking(targetSum, k, i + 1, sum);
			//回溯
			path.removeLast();
			//回溯
			sum -= i;
		}
	}
}
```

### 7.3 电话号码 的字母组合

> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



```java
class Solution {
    List<String> resList = new ArrayList<>();
    StringBuilder item = new StringBuilder();
    public List<String> letterCombinations(String digits) {
        if(digits.equals("")){
            return resList;
        }
        int num = Integer.parseInt(digits);
        List<Integer> list = new ArrayList<>();
        while(num > 1 ){
            int i  = 0;
            i = num % 10;
            num = num / 10;
            list.add(i);
        }
        letterCombinationsRec(list,0);
        
        return resList;
    }

    public void letterCombinationsRec(List<Integer> list, int startIndex){
        if(item.length() == list.size()){
            resList.add(new String(item));
            return;
        }
        int index = list.size() - startIndex - 1 ;
        for(int j = 0; j < 4; j++){
            char ch = getLetter(list.get(index),j);
            if(ch == '0'){
                break;
            }
            item.append(ch);
            letterCombinationsRec(list, startIndex + 1);
            item.deleteCharAt(item.length() - 1);
        } 
    }
    public char getLetter(int num, int index){
        switch(num){
            case 2 :
            switch(index){
                case 0 : return 'a';
                case 1 : return 'b';
                case 2 : return 'c';
            }
            break;
            case 3 :
            switch(index){
                case 0 : return 'd';
                case 1 : return 'e';
                case 2 : return 'f';
            }
            break;
            case 4 :
            switch(index){
                case 0 : return 'g';
                case 1 : return 'h';
                case 2 : return 'i';
            }
            break;
            case 5 :
            switch(index){
                case 0 : return 'j';
                case 1 : return 'k';
                case 2 : return 'l';
            }
            break;
            case 6 :
            switch(index){
                case 0 : return 'm';
                case 1 : return 'n';
                case 2 : return 'o';
            }
            break;
            case 7 :
            switch(index){
                case 0 : return 'p';
                case 1 : return 'q';
                case 2 : return 'r';
                case 3 : return 's';
            }
            break;
            case 8 :
            switch(index){
                case 0 : return 't';
                case 1 : return 'u';
                case 2 : return 'v';
            }
            break;
            case 9 :
            switch(index){
                case 0 : return 'w';
                case 1 : return 'x';
                case 2 : return 'y';
                case 3 : return 'z';
            }
            break;
        }
        return '0';
    }
}
```



### 7.4 组合总和

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

```java
class Solution {
    List<List<Integer>> resList = new LinkedList<>();
    List<Integer> item = new LinkedList<>();
    int sum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates.length == 0){
            return resList;
        }
        combinationSumHelper(candidates, target, 0);
        return resList;
    }
    public void combinationSumHelper(int[] candidates, int target,int startIndex){
        if (startIndex >= candidates.length)
            return;

        if(sum == target){
            resList.add(new LinkedList<>(item));
            return;
        } 
        if (sum > target){
            return;
        }

        for(int i = startIndex; i < candidates.length; i++){
            sum += candidates[i];
            item.add(candidates[i]);
            combinationSumHelper(candidates, target, i);
            sum -= candidates[i];
            item.remove(item.size() - 1);
        }

    }
}
```

### 7.5 组合总和 II

> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
>
> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。
>
> **注意：**解集不能包含重复的组合。 
>
>  
>
> **示例 1:**
>
> ```
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 输出:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> ```



```java
class Solution {
    List<List<Integer>> resList = new LinkedList<>();
    List<Integer> item = new LinkedList<>();
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        if(candidates.length <= 0){
            return resList;
        }
        Arrays.sort(candidates);
        combinationSum2Helper(candidates,target,0);
        return resList;

    }
    public void combinationSum2Helper(int[] candidates, int target, int startIndex){

        if(sum == target) {
            resList.add(new LinkedList(item));
            return;
        }
        if(sum > target){
            return;
        }
        for(int i = startIndex; i < candidates.length; i++){
            sum += candidates[i];
            item.add(candidates[i]);
            combinationSum2Helper(candidates, target, i + 1);
            sum -= candidates[i];
            item.remove(item.size() - 1);
            //去重
            if(i < candidates.length - 1  && candidates[i] == candidates[i + 1]){
                int k = i + 1;
                while(candidates[i] == candidates[k]){
                    k++;
                    if(k >= candidates.length){
                        return;
                    }
                }
                i = k - 1;
            }
        }
    }
}
```



### 7.6 分割回文串

> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。
>
> **回文串** 是正着读和反着读都一样的字符串。
>
> **示例 1：**
>
> ```
> 输入：s = "aab"
> 输出：[["a","a","b"],["aa","b"]]
> ```



```java
class Solution {
    List<List<String>> lists = new ArrayList<>();
    Deque<String> deque = new LinkedList<>();

    public List<List<String>> partition(String s) {
        backTracking(s, 0);
        return lists;
    }

    private void backTracking(String s, int startIndex) {
        //如果起始位置大于s的大小，说明找到了一组分割方案
        if (startIndex >= s.length()) {
            lists.add(new ArrayList(deque));
            return;
        }
        for (int i = startIndex; i < s.length(); i++) {
            //如果是回文子串，则记录
            if (isPalindrome(s, startIndex, i)) {
                String str = s.substring(startIndex, i + 1);
                deque.addLast(str);
            } else {
                continue;
            }
            //起始位置后移，保证不重复
            backTracking(s, i + 1);
            deque.removeLast();
        }
    }
    //判断是否是回文串
    private boolean isPalindrome(String s, int startIndex, int end) {
        for (int i = startIndex, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
```

### 7.7 复原IP地址

> **有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。
>
> - 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。
>
> 给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。
>
> **示例 1：**
>
> ```
> 输入：s = "25525511135"
> 输出：["255.255.11.135","255.255.111.35"]
> ```

```java
class Solution {
    List<String> resList = new ArrayList<>();
    StringBuilder item = new StringBuilder();
    int pointConut = 0;

    public List<String> restoreIpAddresses(String s) {
        if( s.length() <= 0 || s.length() > 12) {
            return resList;
        }
        restoreIpAddressesHelper(s,0);
        return resList;
    }

    public void restoreIpAddressesHelper(String s, int startIndex){
        if(pointConut > 3){
            return;
        }
        if(startIndex >= s.length() && pointConut == 3) {
            resList.add(new String(item));
            return;
        }
        for(int i = startIndex; i < s.length(); i++){
            if (i - startIndex > 3){
                return;
            }
            if(isRight(s, startIndex, i)){

            } else{
                continue;
            }
            restoreIpAddressesHelper(s, i + 1);
            removeLastForItem();
        }
    }
    public boolean isRight(String s, int start, int end){
        if(start == end ){
            if(item.length() != 0){
                pointConut++;
                item.append("." + s.charAt(start));
            } else{
                item.append(s.charAt(start));
            }
            return true;
        }
        if(s.charAt(start) == '0') { 
            return false;
        }
        StringBuilder sb = new StringBuilder();
        for(int o = start; o <= end; o++){
            sb.append(s.charAt(o));
        }
        String a = new String(sb);
        long num = Integer.parseInt(a);
        if(num <= 255){
            if(item.length() != 0){
                item.append("." + a);
                pointConut++;
            } else{
                item.append(a);
            }
            return true;
        } else {
            return false;
        }
    }

    public void removeLastForItem(){
        int index = 0;
        for(int j = item.length() - 1; j >= 0; j--) {
            if(item.charAt(j) == '.'){
                index = j;
                break;
            }
        }
        if(index == 0){
            item = new StringBuilder();
        } else {
            // StringBuilder的delete方法包头不包尾
            item.delete(index, item.length());
            pointConut--;
        }
    }
}
```

### 7.8 子集

> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```

```java
class Solution {
    List<List<Integer>> resList = new ArrayList<>();
    List<Integer> item = new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        resList.add(new LinkedList<>());
        if(nums.length <= 0){
            return resList;
        }
        subsetsHelper(nums, 0);
        return resList;
    }
    public void subsetsHelper(int[] nums, int startIndex){
        if(item.size() > 0){
            resList.add(new LinkedList<>(item));
        }
        if(startIndex >= nums.length){
            return;
        }
        for(int i = startIndex; i < nums.length; i++){
            item.add(nums[i]);
            subsetsHelper(nums, i + 1);
            item.removeLast();
        }
    }
}
```



### 7.9 子集二

> 给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,2]
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
> ```



```java
class Solution {
    List<List<Integer>> resList = new ArrayList<>();
    List<Integer> item = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        resList.add(new LinkedList<>(item));
        if (nums.length <= 0){
            return resList;
        }
        Arrays.sort(nums);
        subsetsWithDupHelper(nums, 0);
        return resList;
    }
    public void subsetsWithDupHelper(int[] nums, int startIndex) {
        if(item.size() > 0){
            resList.add(new LinkedList<>(item));
        }
        if(startIndex >= nums.length){
            return;
        }
        for(int i = startIndex; i < nums.length; i++) {
            item.add(nums[i]);
            subsetsWithDupHelper(nums, i + 1);
            item.removeLast();
            // 去重
            if(i < nums.length - 1 && nums[i] == nums[i + 1]){
                int k = i + 1;
                while(nums[i] == nums[k]){
                    k++;
                    if( k >= nums.length){
                        return;
                    }
                }
                i = k - 1;
            }
        }
    }
}
```

### 7.10 非递减子序列

> 给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
>
> **示例 1：**
>
> ```
> 输入：nums = [4,6,7,7]
> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> ```

* #### 思路

  这题的难点在于：如何去重，也就是对于一个路径或者说同一层而言，是否存在在重复的元素，只要把每一层的重复元素过滤掉后，就能达到去重效果。

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracking(nums, 0);
        return result;
    }
    private void backTracking(int[] nums, int startIndex){
        if(path.size() >= 2)
                result.add(new ArrayList<>(path));            
        HashSet<Integer> hs = new HashSet<>();
        for(int i = startIndex; i < nums.length; i++){
            if(!path.isEmpty() && path.get(path.size() -1 ) > nums[i] || hs.contains(nums[i]))
                continue;
            hs.add(nums[i]);
            path.add(nums[i]);
            backTracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```



### 7.11 全排列

> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]
> ```

* #### 思路

  这题的难点在于：路径的选择要记录已经选择的元素，然后进行筛选。

```java
class Solution {
    List<List<Integer>> resList = new ArrayList<>();
    List<Integer> item = new LinkedList<>();
    int[] path;
    public List<List<Integer>> permute(int[] nums) {
        path = new int[nums.length];
        permuteHelper(nums);
        return resList;
    }
    public void permuteHelper(int[] nums){
        if(item.size() >= nums.length){
            resList.add(new LinkedList<>(item));
            return;
        }
        for(int i = 0; i < path.length; i++){
            if(path[i] == 0){
                item.add(nums[i]);
                path[i] = 1;
                permuteHelper(nums);
                item.removeLast();
                path[i] = 0;
            }
        }
    }
}
```



### 7.12 重新安排行程

> 332

```java
class Solution {
    private LinkedList<String> res;
    private LinkedList<String> path = new LinkedList<>();

    public List<String> findItinerary(List<List<String>> tickets) {
        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));
        path.add("JFK");
        boolean[] used = new boolean[tickets.size()];
        backTracking((ArrayList) tickets, used);
        return res;
    }

    public boolean backTracking(ArrayList<List<String>> tickets, boolean[] used) {
        if (path.size() == tickets.size() + 1) {
            res = new LinkedList(path);
            return true;
        }

        for (int i = 0; i < tickets.size(); i++) {
            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {
                path.add(tickets.get(i).get(1));
                used[i] = true;

                if (backTracking(tickets, used)) {
                    return true;
                }

                used[i] = false;
                path.removeLast();
            }
        }
        return false;
    }
}
```





```java
class Solution {
    Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();
    List<String> itinerary = new LinkedList<String>();

    public List<String> findItinerary(List<List<String>> tickets) {
        for (List<String> ticket : tickets) {
            String src = ticket.get(0), dst = ticket.get(1);
            if (!map.containsKey(src)) {
                map.put(src, new PriorityQueue<String>());
            }
            map.get(src).offer(dst);
        }
        dfs("JFK");
        Collections.reverse(itinerary);
        return itinerary;
    }

    public void dfs(String curr) {
        while (map.containsKey(curr) && map.get(curr).size() > 0) {
            String tmp = map.get(curr).poll();
            dfs(tmp);
        }
        itinerary.add(curr);
    }
}
```



### 7.13 N皇后



```java
class Solution {
    List<List<String>> resList = new LinkedList<>();
    List<String> item = new ArrayList<>();


    public List<List<String>> solveNQueens(int n) {
        int[][] array = new int[n][n];
        solveNQueensHelper(n, 0, array);
        return resList;

    }
    public void solveNQueensHelper(int n,int startIndex, int[][] array) {
        if(item.size() == n) {
            resList.add(new LinkedList<>(item));
            return;
        }
        for(int i = 0; i < n; i++){
            if(array[startIndex][i] == 0){
                StringBuilder sb = new StringBuilder();
                for(int k = 0; k < n; k++){
                    if(k == i){
                        sb.append("Q");
                    } else{
                        sb.append(".");
                    }
                }
                item.add(new String(sb));
                int m = i + 1;
                int b = i - 1;
                for(int h = startIndex + 1; h < n; h++){
                    array[h][i]++;
                    if (m < n){
                        array[h][m]++;
                        m++;
                    }
                    if (b > -1) {
                        array[h][b]++;
                        b--;
                    }
                }
                solveNQueensHelper(n, startIndex + 1, array);
                m = i + 1;
                b = i - 1;
                for(int h = startIndex + 1; h < n; h++){
                    array[h][i]--;
                    if (m < n){
                        array[h][m]--;
                        m++;
                    }
                    if (b > -1) {
                        array[h][b]--;
                        b--;
                    }
                }
                item.remove(item.size() - 1);
            }
        }
    }
}
```



## 8、贪心算法

> **贪心的本质是选择每一阶段局部最优，从而达到全局最优。**
>
> 举个例子：就比如说有一堆钞票，你可以拿走10张，如果想要拿到总金额最大，就要每次都拿额度最大的钞票。那如果想要把一个背包尽量填满，如何选择物品，显然如果只拿最大不是理想的答案，这时就要用到动态规划了。

* ### 贪心的套路（什么时候用贪心）

  关于贪心算法的使用一般要看情况模拟出来，**通过局部最优推出全局最优**，如果想要理论化地判断贪心算法能否使用，一般数学证明有如下两种方法：1. 数学归纳法 2. 反证法

  有些题目不用推理就能推断出局部最优推出去全局最优，就比如上述的例子。但是有些题目就需要数学推导。

* ### 贪心的一般解题步骤

  贪心算法一般分为如下四步：

  * 将问题分解为若干个子问题
  * 找出适合的贪心策略
  * 求解每一个子问题的最优解
  * 将局部最优解堆叠城全局最优解
  * 

### 8.1 分发饼干

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
> 示例  1:
>
> - 输入: g = [1,2,3], s = [1,1]
> - 输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。

`Arrays.sort `底层实际上采用了三种排序方式。当数据量在 [0 - 47) 时，采用**插入排序**，[47, 286) 时采用**双轴快速排序**，大于等于 286 时采用**归并排序**。不过这还有一个我在看源码注释时发现的点，当数据量大于 286 但数组不是高度结构化的时候采用双轴快速排序替换归并排序。

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        //用来记录以满足的孩子的索引
        List<Integer> list = new ArrayList<>();
        // 记录满足孩子的索引
        int index = 0;
        
        Arrays.sort(g);
        Arrays.sort(s);
        
        /*
        // 冒泡排序
        for(int i = 0; i < s.length - 1; i++){
            for (int j = 0; j < s.length - 1 - i; j++){
                if(s[j] > s[j + 1]){
                    int temp = s[j];
                    s[j] = s[j + 1];
                    s[j + 1] = temp;
                }
            }
        }
        for(int i = 0; i < g.length - 1; i++){
            for (int j = 0; j < g.length - 1 - i; j++){
                if(g[j] > g[j + 1]){
                    int temp = g[j];
                    g[j] = g[j + 1];
                    g[j + 1] = temp;
                }
            }
        }
        */
        for(int i = 0; i <= s.length - 1 && index <= g.length - 1; i++){
            if(s[i] >= g[index]){
                index++;
            }
        }
        return index;
    }
}
```



### 8.2 摆动序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

* ### 思路一（贪心算法）

  **局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值**。

  将本题分情况来讨论，基本上只有三种情况：

  1. 上坡下坡中有平坡
  2. 数组收尾两端
  3. 单调坡中有平坡

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            //得到当前差值
            curDiff = nums[i] - nums[i - 1];
            //如果当前差值和上一个差值为一正一负
            //等于0的情况表示初始时的preDiff
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```

* ### 思路二（动态规划）?

  考虑用动态规划的思想来解决这个问题。

  很容易可以发现，对于我们当前考虑的这个数，要么是作为山峰（即 nums[i] > nums[i-1]），要么是作为山谷（即 nums[i] < nums[i - 1]）。

  - 设 dp 状态`dp[i][0]`，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度
  - 设 dp 状态`dp[i][1]`，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度

  则转移方程为：

  - `dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中`0 < j < i`且`nums[j] < nums[i]`，表示将 nums[i]接到前面某个山谷后面，作为山峰。
  - `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中`0 < j < i`且`nums[j] > nums[i]`，表示将 nums[i]接到前面某个山峰后面，作为山谷。

  初始状态：

  由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：`dp[0][0] = dp[0][1] = 1`。

  ```java
  // DP
  class Solution {
      public int wiggleMaxLength(int[] nums) {
          // 0 i 作为波峰的最大长度
          // 1 i 作为波谷的最大长度
          int dp[][] = new int[nums.length][2];
  
          dp[0][0] = dp[0][1] = 1;
          for (int i = 1; i < nums.length; i++){
              //i 自己可以成为波峰或者波谷
              dp[i][0] = dp[i][1] = 1;
  
              for (int j = 0; j < i; j++){
                  if (nums[j] > nums[i]){
                      // i 是波谷
                      dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);
                  }
                  if (nums[j] < nums[i]){
                      // i 是波峰
                      dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);
                  }
              }
          }
  
          return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
      }
  }
  ```




### 8.3 最大子序和

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> 示例:
>
> - 输入: [-2,1,-3,4,-1,2,1,-5,4]
> - 输出: 6
> - 解释: 连续子数组  [4,-1,2,1] 的和最大，为  6。

* #### 贪心解法

  **局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

  从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。

  **这相当于是暴力解法中的不断调整最大子序和区间的起始位置**。

  **那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？**

  区间的终止位置，其实就是如果 count 取到最大值了，及时记录下来了。例如如下代码：

  ```text
  if (count > result) result = count;
  ```

  **这样相当于是用 result 记录最大子序和区间和（变相的算是调整了终止位置）**。

  ##### 常见误区

  误区一：

  不少同学认为 如果输入用例都是-1，或者 都是负数，这个贪心算法跑出来的结果是 0， 这是**又一次证明脑洞模拟不靠谱的经典案例**，建议大家把代码运行一下试一试，就知道了，也会理解 为什么 result 要初始化为最小负数了。

  误区二：

  大家在使用贪心算法求解本题，经常陷入的误区，就是分不清，是遇到 负数就选择起始位置，还是连续和为负选择起始位置。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 1){
            return nums[0];
        }
        int sum = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++){
            count += nums[i];
            sum = Math.max(sum, count); // 取区间累计的最大值（相当于不断确定最大子序终止位置）
            if (count <= 0){
                count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
            }
        }
       return sum;
    }
}
```



* #### 动态规划

  ```java
  // DP 方法
  class Solution {
      public int maxSubArray(int[] nums) {
          int ans = Integer.MIN_VALUE;
          int[] dp = new int[nums.length];
          dp[0] = nums[0];
          ans = dp[0];
  
          for (int i = 1; i < nums.length; i++){
              dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
              ans = Math.max(dp[i], ans);
          }
  
          return ans;
      }
  }
  ```

  

## 9、动态规划

> 动态规划，（Dynamic Programming），简称DP，如果某一问题有很多重叠子问题用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分与贪心，贪心没有状态推导，而是从局部直接选最优的。

* ### 动态规划的解题思路

  状态转移公式（推导公式）很重要，但动态不仅仅只有递推公式

  对于动态规划问题，我讲拆解为如下五部曲，这五部都搞清楚了，才能说吧动态规划真正掌握了。

  1. 确定dp数组（`dp table`）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

* ### 动态规划应该如何debug

  **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

  **这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

  其实可以自己先思考这三个问题：

  - 这道题目我举例推导状态转移公式了么？
  - 我打印dp数组的日志了么？
  - 打印出来了dp数组和我想的一样么？



### 9.1 斐波那契数

> 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。
>
> 示例 1：
>
> - 输入：2
> - 输出：1
> - 解释：F(2) = F(1) + F(0) = 1 + 0 = 1

```java
class Solution {
    public int fib(int n) {
        if (n < 2) return n;
        int a = 0, b = 1, c = 0;
        for (int i = 1; i < n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```

### 9.2 爬楼梯

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 注意：给定 n 是一个正整数。
>
> 示例 1：
>
> - 输入： 2
> - 输出： 2
> - 解释： 有两种方法可以爬到楼顶。
>   - 1 阶 + 1 阶
>   - 2 阶



```java
class Solution {
    // 常规方式
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
// 用变量记录代替数组
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        int a = 1, b = 2, sum = 0;

        for(int i = 3; i <= n; i++){
            sum = a + b;  // f(i - 1) + f(i - 2)
            a = b;        // 记录f(i - 1)，即下一轮的f(i - 2)
            b = sum;      // 记录f(i)，即下一轮的f(i - 1)
        }
        return b;
    }
}
```





## 排序算法

![](C:\Users\13218\Desktop\study\interview\image\屏幕截图 2024-01-13 124606.png)

### 冒泡排序

```java
for(int i = 0; i < s.length - 1; i++){
            for (int j = 0; j < s.length - 1 - i; j++){
                if(s[j] > s[j + 1]){
                    int temp = s[j];
                    s[j] = s[j + 1];
                    s[j + 1] = temp;
                }
            }
        }
```

### 插入排序

![](images\1705078589544.jpeg)

### 选择排序

> 每一趟在数组中选择最小或最大的数来进行排序。与最左端或最有端数进行交换。



### 快速排序

一般的快速排序步骤如下：

1. 从要排序的列表中选择一个元素，称作轴（这个翻译有点神奇）pivot。
2. 整理列表，使得轴左侧的元素均小于pivot，轴右侧的元素均大于pivot。（其中等于的放在左右侧均可）这个过程称为partition，结束后轴元素便确定了其最终的位置。
3. 递归的使用1、2的步骤来排序轴左侧和右侧的两个子序列



#### 双轴快速排序

![](images\v2-4368b201ab50e9540fcd0858dbb788ce.jpeg.png)

上图表示在算法过程中的某一个时刻的部分。算法步骤如下：

1. 对于小序列，长度小于27的序列，使用插入排序。（后文JDK 1.8中使用的是47）
2. 选择两个轴元素P1、P2。例如图中选择第一个元素a[left] = P1，最后一个元素a[right] = P2。
3. 我们限定P1 < P2（如果不是，则交换P1、P2）。这样我们就可以分出如下部分：Part I [left, L - 1]为< P1部分，Part II [L, K - 1]为 >= P1且<= P2部分，Part III [G + 1, right - 1]为> P2部分，Part IV [K, G]为还没有确定的部分。
4. 针对当前Part IV中的a[K]，与P1和P2比较，比较后放入Part I II III中的一个。
5. 调整L、K、G到适合的位置。
6. 重复4、5步直到K > G。也就是说PartIV的元素全部分散到Part I II III中，最后是三个Part。
7. 将P1放入PartI的最后一个位置，P2放入PartIII的前一个位置（或者第一个位置）。这样就确定了P1和P2的位置。
8. 对于PartI II III ，重复1-7步。

### 希尔排序

先将待排记录序列分割成为若干子序列分别进行插入排序，待整个序列中的记录"基本有序"时，最后再对全体记录进行一次直接插入排序。

![](C:\Users\13218\Desktop\study\interview\image\屏幕截图 2024-01-13 124142.png)

### 归并排序

> 将序列分为等分的两份，再继续将分好的两份序列再分，直到不可再分为止。之后从左到右开始归并，按照所需要的顺序归并，如果序列里有多个数，则选择序列最左边的数来比较归并。



### 堆排序

> 可以将堆看做是一个完全二叉树。并且，每个结点的值都大于等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于等于其左右孩子结点的值，称为小顶堆。
>
> 堆排序(Heap Sort)是利用堆进行排序的方法。其基本思想为：将待排序列构造成一个大顶堆(或小顶堆)，整个序列的最大值(或最小值)就是堆顶的根结点，将根节点的值和堆数组的末尾元素交换，此时末尾元素就是最大值(或最小值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值(或次小值)，如此反复执行，最终得到一个有序序列。



















## 例题

###  1. 求一个整数的惩罚数

> 给你一个正整数 `n` ，请你返回 `n` 的 **惩罚数** 。
>
> `n` 的 **惩罚数** 定义为所有满足以下条件 `i` 的数的平方和：
>
> - `1 <= i <= n`
> - `i * i` 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 `i` 。

```java
public class Solution {

    static final int[] CACHE = new int[1001];

    static {CACHE[1] = 1;}

    public int punishmentNumber(int n) {
        if (CACHE[n] > 0) return CACHE[n];
        return CACHE[n] = (valid(n * n, n) ? n * n : 0)
                        + punishmentNumber(n - 1);
    }

    boolean valid(int source, int target) {
        if (source == target) return true;
        // 如果 source 比 target 小，那么 source 切分之后的总和只会更小
        if (source < target) return false;
        // 例如：n = 36，source = n * n = 1296
        // - 1296 % 10 = 6
        // - 1296 % 100 = 96
        // - 1296 % 1000 = 296
        // - 1296 % 10000 为不切分的情况，在前面的 if 中已判断过。
        for (int base = 10; base <= source; base *= 10) {
            if (valid(source / base, target - source % base)) return true;
        }
        return false;
    }
}
```





















