# 网络IO

## TCP协议

> TCP(Transmission control protocol)即传输控制协议，是一种**面向连接、可靠的**数据传输协议。

* ### TCP报文结构

  ![](image\屏幕截图 2024-01-09 055949.png)

* ### 三次握手（建立连接）

![](image\屏幕截图 2024-01-09 054836.png)

**第一次握手** TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x **序号(sequence number)**，此时，TCP客户端进程进入了 **SYN-SENT** 同步已发送状态

**第二次握手** TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1（表示合法），SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 **SYN-RCVD** 同步收到状态

**第三次握手** TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入**ESTABLISHED已建立连接状态** 触发三次握手



* ### 四次挥手(关闭连接)

  ![](image\屏幕截图 2024-01-09 055203.png)

  **第一次挥手** 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入**FIN-WAIT-1（终止等待1）**状态

  **第二次挥手** 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了**CLOSE-WAIT 关闭等待状态**

  **第三次挥手** 客户端接收到服务器端的确认请求后，客户端就会进入**FIN-WAIT-2（终止等待2）**状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了**LAST-ACK（最后确认）**状态，等待客户端的确认。

  **第四次挥手** 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了**TIME-WAIT（时间等待）**状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入**CLOSED关闭状态**，服务器端接收到确认报文后，会立即进入**CLOSED关闭状态**，到这里TCP连接就断开了，四次挥手完成



## IO 多路复用机制

> 首先IO多路复用会提交一批需要监听的[文件句柄](https://www.zhihu.com/search?q=文件句柄&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A3015478357})（socket也是一种文件句柄）到内核，由内核开启一个线程负责监听，把轮询工作交给内核，当有事件发生时，由内核通知用户程序。这不需要用户程序开启更多的线程去处理连接，也不需要用户程序切换到内核态去轮询，用一个线程就能处理大量网络IO请求

对于多路复用器的多路选择算法常见的有三种：select 模型、poll 模型、epoll 模型。

|              | select                                                       | poll                                                         | epoll                                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------- |
| 性能         | 随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差 | 随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差 | 随着连接数的增加，性能基本没有变化                |
| 连接数       | 一般1024                                                     | 无限制                                                       | 无限制                                            |
| 内存拷贝     | 每次调用select拷贝                                           | 每次调用poll拷贝                                             | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 数据结构     | bitmap                                                       | 数组                                                         | 红黑树                                            |
| 内在处理机制 | 线性轮询                                                     | 线性轮询                                                     | FD挂在红黑树，通过事件回调callback                |
| 时间复杂度   | O(n)                                                         | O(n)                                                         | O(1)                                              |

* ### select 函数

  ```c
  select(int nfds, fd_set *r, fd_set *w, fd_set *e, struct timeval *timeout)
  ```

  想要使用这个方法，首先可以看出要传入三个集合，这个集合都是`bitmap`类型的，分别表示`readfds，writefds，exceptfds`，读、写、异常集合。通过`0/1`来表示集合对应位置的**fd（file description 文件描述符）**是否关心对应事件。

  当用户进程调用select方法后，就会进入阻塞，然后就会开始轮询集合，直到集合中就绪的fd到达设置的阈值，或者超时，函数返回。返回后可以通过遍历集合来处理对应fd请求。

  select存在的问题：

  1. 大小有限制。为1024，由于每次select函数调用都需要在用户空间和内核空间传递这些参数，为了提升拷贝效率，linux限制最大为1024。
  2. 每次调用 select() 时，需要把 fd 数据从用户态拷贝到内核态，频繁复制开销很大；
  3. 每次遍历集合有哪些事件发生，效率低下。

* ### poll 函数

  ```c
  poll(struct pollfd *fds, int nfds, int timeout)
  
  struct pollfd {
  	int fd;
  	short events;
  	short revents;
  }
  ```

  poll函数需要传一个pollfd结构数组，其中fd表示文件描述符，events表示关心的事件，revents表示发生的事件，当有事件发生时，内核通过这个参数返回回来。

  poll相比select的改进：

  1. 传不固定大小的数组，没有1024的限制了（问题1）
  2. 将关心的事件和实际发生的事件分开，不需要每次都重新设置参数（问题2）。例如poll数组传1024个fd和事件，实际只有一个事件发生，那么只需要重置一下这个fd的revent即可，而select需要重置1024个bit。

  poll没有解决select的问题3和4。另外，虽然poll没有1024个大小的限制，但每次依然需要在用户和内核空间传输这些内容，数量大时效率依然较低。

  这几个问题的根本实际很简单，核心问题是[select/poll方法](https://www.zhihu.com/search?q=select%2Fpoll方法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A3015478357})对于内核来说是无状态的，内核不会保存用户调用传递的数据，所以每次都是全量在用户和内核空间来回拷贝，如果调用时传给内核就保存起来，有新增文件描述符需要关注就再次调用增量添加，有事件触发时就只返回对应的文件描述符，那么问题就迎刃而解了，这就是epoll做的事情。

* ### Epoll 

  ```c
  int epoll_create(int size);
  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
  int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
  typedef union epoll_data {
     void *ptr;
     int fd;
     uint32_t u32;
     uint64_t u64;
  }epoll_data_t;
  
  struct epoll_event {
     uint32_t events;   // epoll events
     epoll_data_t data; // user data variable
  }
  ```

  - epoll_create() 系统启动时，在 Linux 内核里创建 epoll 实例（申请一个红黑树 rbTree 和就绪链表 readyList），以便存放 socket 节点；

  - epoll_ctl() 每新建一个连接，都通过该函数操作 epoll 对象，在这个对象的红黑树里增、删、改对应的 socket 节点，绑定一个回调函数；

  - epoll_wait() 轮询所有的回调集合，并完成对应的 IO 操作。相应分三步：

  - - 阻塞线程
    - 内核查找红黑树中准备好的 socket，放入就绪链表 rdlist
    - 就绪列表中的内容复制到 events（从内核态复制到用户态），准备循环处理这些已就绪的 socket 节点

  - **epoll模型又有LT和ET模式**

  - LT 和 ET：

  - - LT，level triggered，水平触发，又叫条件触发。当被监控的 fd 上有可读写的事件时，epoll_wait() 会通知处理程序去读写。如果这次没有把数据一次性全部读写完，那么下次调用 epoll_wait() 时，它还会通知你上次没有读写完的 fd，可继续读写。而且我们不需要读写的 fd，它也会一直通知你。
    - ET，edge triggered，边缘触发。当被监控的 fd 上有可读写事件时，epoll_wait() 会通知处理程序去读写。如果这次没有把数据全部读完，下次将不再通知。
    - 学过计算机组成原理的应该知道脉冲信号，其实 ET 和 LT 的原理和电信号的变化差不多。LT 就是只有高电平(1)或低电平(0)时才触发通知，只要在指定的状态上，就会得到通知；ET 是只有电平发生变化时(从高电平到低电平，或者从低到高)，才触发通知。



## Reactor 模式

> IO多路复用是操作系统的底层实现，借助IO多路复用我们实现了一个线程就可以处理大量网络IO请求，那么接收到这些请求后该如何高效的响应，这就是reactor要关注的事情，reactor模式是基于事件的一种[设计模式](https://www.zhihu.com/search?q=设计模式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A3015478357})。在reactor中分为3中角色：
> **Reactor**：负责监听和分发事件
> **Acceptor**：负责处理连接事件
> **Handler**：负责处理请求，读取数据，写回数据

从线程的角度出发，reactor又可以分为单reactor单线程，单reactor多线程，多reactor多线程3种。

* ### 单Reactor单线程

  ![image-20240109072922285](C:\Users\13218\AppData\Roaming\Typora\typora-user-images\image-20240109072922285.png)

  处理过程：reactor负责监听连接事件，当有连接到来时，通过acceptor处理连接，得到建立好的socket对象，reactor监听scoket对象的读写事件，读写事件触发时，交由handler处理，handler负责读取请求内容，处理请求内容，响应数据。

* ### 单reactor多线程

  ![](image\屏幕截图 2024-01-09 072947.png)

  既然处理请求这里可能由性能问题，那么这里可以开启一个线程池来处理，这就是单reactor多线程模式，请求连接、读写还是由主线程负责，处理请求内容交由线程池处理，相比之下，多线程模式可以利用cpu多核的优势。单仔细思考这里依然有性能优化的点，就是对于请求的读写这里依然是在主线程完成的，如果这里也可以多线程，那效率就可以进一步提升。

* ### 多reactor多线程

  ![](image\屏幕截图 2024-01-09 073048.png)

  多reactor多线程下，mainReactor接收到请求交由acceptor处理后，mainReactor不再读取、写回网络数据，直接将请求交给**subReactor线程池处理**，这样读取、写回数据多个请求之间也可以并发执行了。



### Redis 网络IO模型

> redis网络IO模型也用到了Reactor模式实现的，只不过有一些不一样。

* #### 单线程模式

在redis6.0以前属于单Reactor单线程的模式。如图：

![](image\屏幕截图 2024-01-09 073940.png)

在Linux下，IO多路复用程序使用**epoll**实现的，负责监听服务端连接、socket的读取、写入事件等，然后将事件丢到**事件队列**中去。

以一个简单的`get key` 简单命令为例。

![](image\屏幕截图 2024-01-09 074827.png)

当redis服务器启动时，主线程运行，监听指定的端口，**将连接事件绑定命令应答处理器**。

客户端请求连接时，就会触发连接事件，IO多路复用程序将连接事件放入事件队列，事件分发起就会交由命令应答处理器处理请求：**创建socket，将ae_readable(可读事件)关联命令请求处理器，交由IO多路复用程序监听**

连接建立之后，就开始执行命令。

![](image\屏幕截图 2024-01-09 145543.png)

客户端发送`get key`命令，**socket接收到数据变成可读，这时IO多路复用程序就会监听到可读事件，将事件放入事件队列，有事件分发器分发给之前绑定的命令请求处理器执行**。

命令请求处理器**接收到数据后，解析数据，执行get命令，从内存中查询到key对应的数据，并将ae_writeable（写入事件）关联命令应答处理器，交由IO多路复用程序监听**

当客户端准备好接收数据时，**命令请求处理器命令请求处理器产生ae_writeable事件，IO多路复用程序监听到写事件，将写事件丢到事件队列，由事件分发器发给命令响应处理器进行处理。**命令响应处理器将数据写回socket返回给客户端。

* #### 多线程模式

redis 6.0多线程模型思想上类似单reactor多线程和多reactor多线程，但不完全一样，这两者handler对于逻辑处理这一块都是使用线程池，而redis命令执行依旧保持单线程。如下：

![](image\屏幕截图 2024-01-09 075351.png)

**多线程 IO 模型中的“多线程”仅用于接受、解析客户端的请求，然后将解析出的请求 写入到任务队列。而对具体任务（命令）的处理，仍是由主线程处理**



## http和https的区别

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



##  SSL是什么意思

> SSL(Secure Sockets Layer 安全套接层)及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。如今被广泛使用，如网页，电子邮件，互联网传真，即时消息和语音在IP电话（VoIP）。其中网站是通过使用TLS来保护WEB浏览器与服务器之间的通信安全。

**SSL (Secure Socket Layer)**

为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。

**SSL协议可分为三层：**

SSL握手协议(SSL Handshake Protocol)：握手协议是客户机和服务器用SSL连接通信时使用的第一个子协议，握手协议包括客户机与服务器之间的一系列消息。SSL中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和MAC算法以及保密密钥，用来保护在SSL记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。

SSL记录协议(SSL Record protocol)：记录协议在客户机和服务器握手成功后使用，即客户机和服务器鉴别对方和确定安全信息交换使用的算法后，进入SSL记录协议，记录协议向SSL连接提供两个服务：

（1）保密性：使用握手协议定义的秘密密钥实现

（2）完整性：握手协议定义了MAC，用于保证消息完整性

SSL警报协议(SSL Handshake Protocol)：客户机和服务器发现错误时，向对方发送一个警报消息。如果是致命错误，则算法立即关闭SSL连接，双方还会先删除相关的会话号，秘密和密钥。每个警报消息共2个字节，第1个字节表示错误类型，如果是警报，则值为1，如果是致命错误，则值为2；第2个字节制定实际错误类型。

**SSL协议提供的服务主要有：**

1)认证用户和服务器，确保数据发送到正确的客户机和服务器;

2)加密数据以防止数据中途被窃取;

3)维护数据的完整性，确保数据在传输过程中不被改变。

**SSL协议的工作流程：**

1：客户端的浏览器向服务器传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。

2：服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。

3：客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。

4：用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。

5：如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。

6：如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。

7：服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。

8：客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。

9：服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。

10：SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。





HTTPS 中的 S代表的是SSL/TLS，SSL是TLS的前身，现在大多数浏览器只支持TLS了。



**对称加密：**

通信双方都用同样的解密规则来对密码进行加解密。

**被对称加密：**

服务端有一个私钥和一个公钥。公钥让客户端知道。

加密规则是：

数据经过公钥加密后，只能被私钥解密。

数据经过私钥加密后，只能被公钥解密



> SSL证书

SSL证书是由特定机构（大家都认可的证书机构）发送给网站的，里面记录了服务器的公钥、所属域名等信息，在服务器安装SSL证书，就可以通过HTTPS来访问服务器了。（HTTPS的默认端口443）



HTTPS请求过程：

![](C:\Users\13218\Desktop\study\网络\image\屏幕截图 2024-02-17 235521.png)

**由于会话密钥没有被非加密传输，是非常安全的。故得到会话密钥后，通信双方就只使用对称加密来进行数据传输，减小开销**





## XSS

> Cross Site Scripting 跨站脚本

攻击者通过一些手段（木马程序）在用户访问的网页html中加入预定义好的脚本，这个脚本可能会盗取用户的数据和隐私。



防御：

对输入（和URL参数）进行过滤，对输出进行编码Cookie 设置 http-only



## CSRF（跨站请求伪造漏洞）

> **CSRF(Cross-Site Request Forgery)**，跟XSS漏洞攻击一样，存在巨大的危害性
>
> 你可以这么来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等

黑客会伪造一个网站，当你进入网站时，就会触发请求，如果这个请求资源路径没有CSRF防御，并且你的登陆cookie并没有失效，就能对你的用户进行非法操作。



**防御手段：**

1. 加入验证码，这时最有效简单的请求。
2. 验证 Referer，即HTTP协议带的参数，即请求来源，服务端可以验证请求来源来防御；但是有些浏览器可以修改这个属性，所以这个方法并不是最好的
3. Anti CSRF Token，每次访问网站时，服务端都会发送并记录在服务端一个token来验证请求中是否带上这个防御token，这也可以说是另一种验证码。
4. 加入自定义的 Header与上面的方法类似



