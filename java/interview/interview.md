# interview

## 01-JDK、JER、JVM之间的区别

* **JDK**，java标准开发包，它提供了编译、运行java程序所需的各种根据和资源。**包括Java编译器、java运行时环境**，以及常用的java类库等
* JRE，java运行环境，用于运行java字节码文件。JRE中包括了JVM以及JVM工作所需要的类库，普通用户只需要安装JRE来运行Java程序，而开发者必须安装JDK来编译、调试程序。
* JVM，java虚拟机，是JRE的一部分，他是整个java实现跨平台的最核心的部分，负责运行字节码文件。



## 02-hashCode()与equals之间的关系

在java中，每个对象都可以调用自己的`hashCode()`方法得到自己的哈希值，相当于对象的指纹信息，但是相对于对象的指纹信息，在java中**做不到这么绝对**，但是可以做出一些判断。

* 如果两个对象的hashCode不相同，那么这两个对象肯定不同的两个对象。
* 如果两个对象的hashCode相同，不代表这两个对象一定是同一对象。
* 如果两个对象相同，那么他们的hashCode就一定相同

> 通过new 创建的对象的hashCode是不同的

在java的一些集合类的实现中，在比较两个对象是否相等是，会根据上面的原则。

先调用对象的hashCode()方法得到hashCode进行比较，

如果hashCode不相同，就可以直接认为这两个对象不相同。

如果不相同，通常equals方法的实现会比较重，逻辑比较多，而hashCode()主要就是得到一个数字，比较简单。

所以在重写equals()方法时，就要注意遵守以上的原则。

> 重写equals()方法时，是否要重写hashCode()方法？为什么？

* 如果要重写equals()方法，也尽量重写hashCode方法。

  如果你要比较一个对象A、B；如果B存在于一个集合中，你要遍历这个集合找到这个B，如果你只重写了equals()方法（满足需求的重写，而hashCode没重写不满足需求），就要用效率较低的方式去遍历它。

> 重写equals方法和hashcode的作用？

* 第一点：就是为了更加高效的去比较俩个对象是否相等。第二点：实现特殊的需求。

> 如何重写这两个方法？

* **equals方法的特性**

  1. 自反性，对于任何非空引用x，x.equals(x)应该返回true；
  2. 对称性，x.equals(y),y.equals(x)结果一致
  3. 传递性，x.equals(y),y.equals(z),两种为true，则x.equals(z)也为true
  4. 一致性，
  5. 对于任意非空引用x,x.equals(null)，返回false

* **hashCode()方法的特性**

  。。。



## 03-==和equals方法的区别

* ==：如果是基本数据类型，比较的是值；如果是引用类型，比较的是引用地址
* equals：具体看各个类重写equals方法之后的比较逻辑，比如String类，它的equals比较的是内容是否相等。



## 04-泛型中extends和super的区别

* <? extends T>表示包括T在内的任何T的子类
* <? super T>表示包括T在内的任何T的父类



## 05-String、StringBuffer、StringBuilder的区别

* String是不可变的，如果尝试去修改。会新生成一个字符串对象，StringBuffer和StringBuilder是可变的
* StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更高。

> 什么是线程安全？

当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。
如果一段代码可以保证多个线程访问的时候正确操作共享数据，那么它是线程安全的



## 06-ArrayList的底层工作原理

1. 在构造ArrayList时，如果没有指定容量，那么内部会构造一个空数组，如果指定了容量，那么就构造出对应容量大小的数组
2. 在添加元素时`add(E element)`，先判断数组容量是否足够，如果不够则会扩容，扩容按1.5倍扩容，容量足够后，再把元素添加到数组中
3. 在添加元素时`add(int index,E element)`，如果指定了下标，**先判断下标是否越界，然后再确定数组容量是否足够**，不够进行扩容，然后把元素添加到指定位置，然后后移后面的元素
4. 取元素时，先判断是否越界

> 越界会抛出IndexOutOfBoundsException异常



## 07-ArrayList和LinkedList区别

* ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的
* ArrayList更适合随机查找，LinkedList更加适合删除和添加。
* 另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以它还可以当做队列来使用



## 08-CopyOnWriteArrayList的底层原理是怎么样的

> 什么是CopyOnWrite容器？
>
> CopyOnWrite容器即写时复制的容器，通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器李添加元素，添加完元素之后，会将原容器的地址指向新的容器。
>
> ArrayList 集合不能进行多线程的读写操作，发丢出并发失败的异常

1. 写操作时，是加锁的，防止出现并发写入丢失数据的问题
2. 底层也是通过数组实现的

> CopyOnWriteArrayList优缺点

优点：解决开发工作中的多线程并发问题
缺点：

1. 内存占用问题：很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以使用ConcurrentHashMap来代替。
2. 数据一致性：CopyOnWriteArrayList容器只能保证数据的最终已执行，不能保证数据的实时一致性，所以如果希望写入的数据，马上能读取到，就不能使用CopyOnWriteArrayList。



## 09-红黑树详解

### 红黑树的概念

> 红黑树是一种自平衡的二叉查找树，是一种高效的查找树。它是由 Rudolf Bayer 于1978年发明，在当时被称为平衡二叉 B 树(symmetric binary B-trees)。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。

> **几个重要的概念**

1. 平衡二叉树（AVLTree）：左右子树的高度之差小于1，并且左右子树也是平衡二叉树
2. 二叉搜索树：左节点一定小于根节点，右节点一定大于根节点。左右子树也是二叉搜索树
3. parent：父节点
4. sibling：兄弟节点
5. uncle：叔父节点（ parent 的兄弟节点）
6. grand：祖父节点（ parent 的父节点）

> **为什么需要红黑树？**

对于二叉搜索树，如果数据是随机的，那么它是接近平衡二叉树的，操作效率是很高的；但是对于极端的情况，数据是有序的（递增或者递减的），那么所有的节点都会在根节点的左侧或者右侧，这就导致了操作效率很低。

为了应对这种极端的情况，红黑树就出现了。

> **红黑树的特性**。首先，红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；**通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）。**它同时满足以下特性：

1. 节点是红色或黑色
2. 根是黑色
3. 叶子节点（外部节点，空节点）都是黑色，**这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点**
4. 红色节点的子节点都是黑色
   红色节点的父节点都是黑色
5. 从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点
6. 从任意节点到叶子节点的所有路径都包含相同数目的黑色节点

![](image\14c3c358dc3e4428b59add6dfe85b361.png)

### 红黑树的效率


红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。

查找操作时，它和普通的相对平衡的二叉搜索树的效率相同，都是通过相同的方式来查找的，没有用到红黑树特有的特性。

但如果插入的时候是有序数据，那么红黑树的查询效率就比二叉搜索树要高了，因为此时二叉搜索树不是平衡树，它的时间复杂度O(N)。

插入和删除操作时，由于红黑树的每次操作平均要旋转一次和变换颜色，所以它比普通的二叉搜索树效率要低一点，不过时间复杂度仍然是O(logN)。总之，红黑树的优点就是对有序数据的查询操作不会慢到O(logN)的时间复杂度。

* **红黑树和AVL树的比较**
  AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异
  红黑树的插入删除比AVL树更便于控制操作
  红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）

### 旋转操作

***\*左旋\****是将某个节点旋转为其右孩子的左孩子，而***\*右旋\****是节点旋转为其左孩子的右孩子。

![](image\95c9869ab8a34dbcae8c03145dc27156.jpg)

















## 10-HashMap详解

> HashMap 是一个集合，键值对的集合，每个节点用Node<K,V>表示
>
> Node是一个内部类，这里的key为键，value为值，next指向下一个元素，可以看出HashMap中的元素不是一个单纯的键值对，还包含下一个元素的引用。

```java
static class Node<K,V> implements Map.Entry<K,V> {
   final int hash;
   final K key;
   V value;
   Node<K,V> next;
    ...
```

### HashMap存储元素的过程

```java
HashMap<String,String> map = new HashMap<String, String>();
map.put("测试数据01","01");
map.put("测试数据02","02");
```

它会先计算出键key的hashcode值，然后对这个hashcode值根据HashMap底层存储数组的大小进行取余（对于初始的HashMap，初始的数组大小是16），然后得到一个索引。

根据这个索引定位到位置，得到一个链表（或红黑树）

如果位置是空的，直接将元素放进去

然后会判断这个位置上的所有元素，用equals方法，如果全部都返回false，就会放到链表的尾部（或红黑树中）；如果返回true，就会替换这个位置的元素

> 树化的过程

在jdk1.8中，如果链表长度大于8且节点数组长度大于64的时候，就把链表下所有的节点转为红黑树。

树形化还有一个要求就是数组长度必须大于等于64，否则继续采用扩容策略

总的来说，HashMap默认采用数组+单链表方式存储元素，当元素出现哈希冲突时，会存储到该位置的单链表中。但是单链表不会一直增加元素，当元素个数超过8个时，会尝试将单链表转化为红黑树存储。但是在转化前，会再判断一次当前数组的长度，只有数组长度大于64才处理。否则，进行扩容操作。

### HashMap的Put方法

![](image\屏幕截图 2024-01-22 230523.png)



### HashMap的扩容机制

> HashMap有两个重要的参数：初始容量大小和加载因子，初始容量大小是创建数组分配的默认为16；用数组容量大小乘于加载因子得到一个值，**一旦数组中的元素个数超过该值，就会调用rehash方法将数组容量增加到原来的两倍**，即扩容。
>
> 在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能

在1.7版本：

1. 先生成新数组
2. 遍历老数组中农每个位置上的链表的每个元素
3. 然后根据每个元素的key，并利用hashcode基于新数组的长度，计算每个元素在新数组中的下标
4. 将元素添加到新数组中去
5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

在1.8版本：

1. 先生成新数组

2. 遍历老数组中每个位置上的链表或红黑树

3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去

4. 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置

   a. 统计每个下标位置的元素个数

   b. 如果该位置下的元素个数超过了6，则生成一个新的红黑树，将根节点添加到数组相应位置

   c. 如果该位置下的元素个数没有超过6，就生成链表

5. 同1.7

### HashMap的线程问题

* #### JDK1.7扩容引发的死循环和数据丢失

  HashMap线程不安全主要发生在扩容函数中，其中的`transfer()`方法。并且采用头插法导致链表顺序反转。

* #### JDK1.8中还是会出现数据覆盖的情况

## 11-一个对象从加载到JVM，再到被GC清除，都经历了什么过程？

> **因为实例对象都存储在堆内存中，所以下面说的什么都是有关堆内存的**
>
> Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区
>
> 
>
> - Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
>
> - Tenure generation space 养老区 Old/Tenure
>
> - Permanent Space 永久区 Perm
>
> 
>
> Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间
>
> 
>
> - Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区
>
> - Tenure generation space 养老区 Old/Tenure
>
> - Meta Space 元空间 Meta
>
> 新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
>
> 老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。

1. 首先把字节码文件内容加载到方法区
2. 然后再根据类信息在堆中创建对象
3. 对象首先会分配在堆区中年轻带的Eden（伊甸园）区，经过一次Minor GC后，如果对象存活，就会进入Suvivor区。在后续的每次Minor GC中，如果对象一直存活，就会在Suvivor区来回拷贝，每移动一次，年龄加1
4. 当年龄超过15后，对象依然存活，对象就会进入老年代
5. 如果经过Full GC，被标记为垃圾对象，那么就会被GC线程清理掉



## 12-怎么确定一个对象到底是不是垃圾

1. 引用计数算法：给内存堆中的每个对象记录一个引用个数。引用个数为0，就认为是垃圾。这是早期JDK中使用的方式。无法解决循环引用的问题
2. 可达性算法：这种方式是在内存中，从根对象向下一直找引用，找到的对象就不是垃圾，没找到的对象就是垃圾。



## 13-JVM有哪些垃圾回收算法

* **标记清除算法**

  1.  标记阶段：把垃圾内存标记出来
  2. 清除阶段：直接将垃圾内存回收
  3. 这种算法比较简单，但是会产生大量的内存碎片

* **复制算法**

  为了解决标记清除算法内存碎片问题，就产生了复制算法。复制算法将内存分为大小相等的两半，每次只使用其中一半。垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清除。

  这种算法没有内存碎片，但是他的问题就在于浪费空间。而且，他的效率跟存活对象的个数有关。

* **标记压缩算法**

  为了解决复制算法的缺陷，就提出了标记压缩算法。这种算法在标记阶段根标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将边界以外的所有内存直接清除。

* **分代收集算法**

  分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。

  在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。



## 14-什么是字节码？有什么好处？

编译器（javac）将Java源文件（.java）编译成字节码文件（.class），可以做到一次编译到处运行。不过Java跨平台有一个前提，就是不同的操作系统上安装的JDK或JRE是不一样的，虽然字节码是通用的，但需要把字节码解释成各个操作系统的机器码是需要不同的解释器。



## 15-java中的异常体现

![](image\屏幕截图 2023-12-19 202600.png)



## 16-java的类加载器

![](image\屏幕截图 2023-12-19 202817.png)

* BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载`%JAVA_HOME%lib` 下的jar包和class文件
* ExtClassLoader是AppClassLoader的父类加载器，负责加载`%JAVA_HOME%lib/ext`下的jar包和class类
* AppClassLoader是自定义加载器的父类，负责加载classpath下的类文件

**JDK9后，java开始模块化，.jar文件被淘汰，取而代之的是`.mod`文件**



### 类加载器双亲委派模型

在JVM在加载类时，会委派给Ext和Bootstrap进行加载，如果没有加载到才由自己进行加载

在JDK9时，双亲委派发生了一些变化：在委派给父加载器前，会先判断该类是否能够归属于一个狎鸥亭模块中，如果可以找到这样的归属关系，就优先委派给负责那个模块的类加载器

## 17-JDK1.7到JDK1.8 HashMap发生了什么变化（底层）？

1. 1.7底层是数组+链表，1.8是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询的整体效率
2. 1.7中链表插入使用的头插法；1.8使用的是尾插法，因为它插入key和value时需要判断链表元素的个数，所以需要遍历统计链表元素个数
3. 1.7中的hash算法比较复杂；在1.8中，因为复杂的哈希算法的目的是提高离散列性，来提高HashMap的整体效率，而1.8新增了红黑树，所以可以适当简化hash算法，节省CPU资源



## 18-JVM出现OOM异常会导致进程挂掉吗？

当一个线程在执行代码的过程中，大概率需要创建对象，而创建对象就需要分配内存，如果JVM可用内存不够时会进行垃圾回收，如果垃圾回收完了之后内存还是不够，就会抛出OutOfMemoryError，如果没有捕获它，那么就会抛出一个普通异常一样会导致线程停掉；如果捕获了，那么线程可能就不会停掉。

如果一个进程里面的所有非守护线程都停掉了，那么进程才会挂掉；或者占用操作系统过多内存，就会被操作系统关闭掉。

> 什么是非守护线程？
>
> java有两种状态的线程
> 1.守护线程（例如垃圾回收线程：gc线程）
> 2.非守护线程（用户线程：用户线程即我们手动创建的线程）
>
> 守护线程与非守护线程的区别
> 1.守护线程
> 有一个特征，例如当主线程运行的时候，垃圾回收线程一起运行。
> 当主线程销毁，会和主线程一起销毁。
> 2.非守护线程
> 如果主线程销毁，用户线程继续运行且互不影响。
>
> 可以通过设置`thread.setDaemon(true)`来把一个线程设置为守护线程



## 19-JVM中哪些是线程共享区

![](image\屏幕截图 2023-12-19 204658.png)

* 方法区：被加载的类信息，常量等
* 堆：放的是对象的实例等



## 20-项目中如何排查JVM问题

* **对于还在正常运行的系统**

1. 可以使用jmap来查看JVM中各个区域的使用情况
2. 可以通过jstack来查看线程的运行情况，比如有哪些线程阻塞，死锁等
3. 可以通过jstat命令来查看垃圾回收情况，特别是fullgc，如果fullgc比较频繁，那么就得进行调优了（full gc会导致其它线程挂起）
4. 通过各个命令的结果，或者jvisualvm等工具进行分析
5. 首先，初步猜测频繁发送full gc的原因，如果频繁发送full gc但是又一直没出息内存溢出的溢出，说明fullgc实际上回收了很多对象，所以这些对象最好能在younggc过程就直接被回收掉，避免这些对象进入到老年代；对于这种情况就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代；
6. 同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法，看是否能够避免某些对象的创建，从而节省内存

* **对于已经发生了OOM的系统**

1. 一般系统都会设置发生了OOM时，生成当时的dump（[dʌmp]）转储文件`(-XX:+HeapDumpOnOutOfMemoryError - XX:HeapDumpPath=/usr/local/base)`
2. 我们可以利用`jsisualvm`等工具来分析dump文件
3. 根据dump文件找到异常的实例对，和异常的线程，定位到具体的代码



## 21-深拷贝和浅拷贝

1. 浅拷贝是指只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址指向的对象，他们所指向的对象是同一个

   （父类的clone()方法）

2. 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象

   (序列化和反序列化)

   ```java
   @Override
       protected Object clone() throws CloneNotSupportedException {
           try{
               ByteArrayOutputStream bos = new ByteArrayOutputStream();
               ObjectOutputStream oos = new ObjectOutputStream(bos);
               oos.writeObject(this);
   
               ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
               ObjectInputStream ois = new ObjectInputStream(bis);
   
               return ois.readObject();
   
           }catch (Exception e){
               return super.clone();
           }
       }
   ```



## 22-ConcurrentHashMap的扩容机制

> 为何要引入ConcurrentHashMap？
>
> 在JDK7下，高并发场景下，有可能会出现环形链表的情况；要避免 HashMap的线程安全，有很多解决方法，如改用HashTable 或者用`Collections.synchronizedMap()`方法，但是这两种方法都会大大降低读写的效率
>
> ConcurrentHashMap 的优势在于兼顾性能和线程安全，一个线程进行写操作时，它会锁住一小部分，其他部分的读写不受影响，其他线程访问没上锁的地方不会被阻塞。

* **ConcurrentHashMap详解**

  在1.8以前：

  它由多个 Segment 组合而成。Segment 本身就相当于一个 HashMap 对象。同 HashMap 一样，Segment 包含一个 HashEntry 数组（大小为4），数组中的每一个 HashEntry 既是一个键值对，也是一个链表的头节点。

  像这样的Segament对象，在ConcurrentHashMap集合中有2的N次方个。

  

> JDK8的ConcurrentHashMap和JDK7的ConcurrentHashMap有什么区别？

1.  JDK8中新增了红黑树 

2.  JDK7中使用的是头插法，JDK8中使用的是尾插法 

3.  JDK7中使用了分段锁，而JDK8中没有使用分段锁了 

4.  JDK7中使用了ReentrantLock，JDK8中没有使用ReentrantLock了，而使用了Synchronized 

5.  JDK7中的扩容是每个Segment内部进行扩容,即是**分段扩容的**，不会影响其他Segment，

   而JDK8中的扩容和HashMap的扩容类似，只不过支持了多线程扩容，并且保证了线程安全

### 扩容机制

在JDK7中：

1. 扩容是分段的，是基于segment来实现扩容的
2. 扩容是每个Segment内部进行扩容，不会影响其它的segment，同时Segment继承了ReentrantLock类。使用了分段锁

在JDK8中：

Concurrent不再是分段，或者可以理解为每个桶为一段（也就是每个数组元素Node节点），首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在put，那么这个put线程会帮助去进行元素的转移，虽然叫转移，但是其实是8**基于原数组上的Node信息去生成一个新的Node的，也就是原数组上的Node不会消失，因为在扩容的过程中，如果有其他线程在get也是可以的。**

> Concurrent是如何保证并发安全的？

JDK7中，是通过每段Segment加上分段锁。

JDK8中，是对每个桶中的链表的头结点或者红黑树的头结点加锁。





## 23-使用Executors去创建线程的坏处

> 在阿里巴巴里面，规定不能使用Executors去创建线程池，而是通过ThreadPoolExecutor的方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
>
> 在开发中不允许使用Executors去创建线程池，而是通过ThreadPoolExecutor的方式，这样可以避免资源耗尽的风险。原因是：
>
> **FixedThreadPool和SingleThreadPool：允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM。
> CachedThreadPool和ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM。**

### 什么是线程池策略

* **线程池策略**
  corePoolSize：核心线程数；maximunPoolSize：最大线程数
  每当有新的任务到线程池时，
  第一步： 先判断线程池中当前线程数量是否达到了corePoolSize，若未达到，则新建线程运行此任务，**且任务结束后将该线程保留在线程池中**，不做销毁处理，若当前线程数量已达到corePoolSize，则进入下一步；
  第二步： 判断工作队列(workQueue)是否已满，未满则将新的任务提交到工作队列中，满了则进入下一步；
  第三步： 判断线程池中的线程数量是否达到了maxumunPoolSize，如果未达到，则新建一个工作线程来执行这个任务，如果达到了则使用**饱和策略**来处理这个任务。
  
  **注意： 在线程池中的线程数量超过corePoolSize时，每当有线程的空闲时间超过了keepAliveTime（存活时间），这个线程就会被终止。直到线程池中线程的数量不大于corePoolSize为止。**
  （由第三步可知，在一般情况下，Java线程池中会长期保持corePoolSize个线程。）
  
* **饱和策略**
  当工作队列满且线程个数达到maximunPoolSize后所采取的策略
  AbortPolicy：默认策略；新任务提交时直接抛出未检查的异常RejectedExecutionException，该异常可由调用者捕获。
  CallerRunsPolicy：既不抛弃任务也不抛出异常，使用调用者所在线程运行新的任务。
  DiscardPolicy：丢弃新的任务，且不抛出异常。
  DiscardOldestPolicy：调用poll方法丢弃工作队列队头的任务，然后尝试提交新任务
  自定义策略：根据用户需要定制。
  
* **线程池的优点:**
  减少内存资源的消耗.
  提高请求处理速度
  避免出现OOM

### 线程池的五种状态生命周期

* #### RUNNING

  线程池可以接收新的任务和执行已添加的任务。

  当线程池被创建时就会处于该状态

* #### SHUTDOWN

  不接受新任务，但是能处理已添加的任务

  线程池调用`shutdown()`方法时，就会从RUNNING->SHUTDOWN

* #### STOP

  不接受新任务，不处理已添加的任务，并且会中断正在执行的任务

  线程池调用`shutdownNow()`方法时线程池由(RUNNING或者SHUTDOWN ) -> STOP。

* ### TIDYING

  当所有的任务已终止，`workerConun(有效线程数)`为0，线程进入该状态后会调用`terminated()`方法进入TERMINATED状态

* ### TERMINATED

  当钩子函数terminated()被执行完成之后，线程池彻底终止，就变成TERMINATED状态。

### 使用Executor创建线程池

Executor 创建返回ThreadPoolExecutor对象的方法共三种:

* **newCachedThreadPool :创建可缓存的线程池**

  特点:

  核心线程数0,工作队列SynchronizedQueue是一个不存储元素的队列,可以理解为里面永远是满的,最终会创建非核心线程来执行任务.非核心线程空闲回收时间为60s因为Integer.MAX_VALUE非常大,可以认为可以无限制的创建,所以在资源有限的情况下,容易造成OOM

* **newSingleThreadPool:创建一个单线程的线程池**

  特点:

  只有一个核心线程,超过核心线程数,会放入队列中,LinkedBlockingQueue是长度为Integer.MAX_VALUE,所以可以认为无界,那往队列里面插入任务,容易造成OOM.因为无界,所以,最大线程数和空闲时间这两个参数是无效的.

* **newFixedThreadPool(int nThreads):创建固定长度的线程池**

  特点:

  固定的核心线程池由用户传入.这个和SingleThreadExecutor相似,只是核心线程数不同,所以,在大量线程时容易造成OOM

* **newScheduledThreadPool(int corePoolSize)**

  创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。



自定义的ThreadPoolExecutor：

```java
ThreadPoolExecutor threadPool=
				new ThreadPoolExecutor(5, //核心线程数int corePoolSize
				                       10, //最大池的大小int maximumPoolSize
									   30L,//空闲线程保持时间30long keepAliveTime
									   TimeUnit.SECONDS,//时间单位秒TimeUnit unit
						new ArrayBlockingQueue(5),//阻塞队列,即任务队列
                        new BeimingFactory(),//线程工厂，这里是自定义的线程工厂
						new RejectedExecutionHandler() {//拒绝服务助手  自己定义拒绝策略
					
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.out.println("线程数超过了线程池的容量,拒绝执行任务-->"+r);
						
					}
				});

.....
    
static class BeimingFactory implements ThreadFactory{
    @Override
    public Thread newThread(Runnable r){
        Thread thread = new Thread(r);
        thread.setName("my_factory");
        
        //异常自定义处理
        thread.setUncaughtExceptionHandle((t,e) -> {
           System.out.println(t.getName + "::::::" + e.getMessage()); 
        });
        
        return thread;
    }
}
```



### 线程复用原理

 在源码中，是通过addWork(Runnable firstTask, boolean core)来添加一个新的线程，可以说work是对thread的一个包装；然后其中展现线程复用原理的是在runWork(Worker w)方法，这个方法会一直循环查看任务队列中的任务，然后执行。

从代码层面来说，因为Thread.start()只能调用一次，一旦 这个调用结束，线程就到了stop状态。想要打成复用的目的，就必须从Runnable接口的run()方法上入手；也就说让Thread一直处于循环状态，然后一直检查是否有新的子Runnable对象加入，然后执行它。



## 24-阻塞和非阻塞队列的并发安全原理是什么

### 什么是重入锁

> java.util.concurrent.locks.ReentrantLock
>
> 它完全可以替代synchronized（[ˈsɪŋkrəˌnaɪz]）关键字来实现它的所有功能，而且ReentrantLock锁的灵活度要远远大于synchronized关键字
>
> synchronized同样是可重入锁

* **为什么叫重入锁呢？**

  Re-entrant-Lock即表示可重新反复进入的锁，但是仅限于当前线程。当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次。

* **重入锁最重要的几个方法**

  **1）lock()**

  获取锁，有以下三种情况：

  - 锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；
  - 当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；
  - 其他线程持有锁：当前线程会休眠等待，直至获取锁为止；

  **2）lockInterruptibly()**

  获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。

  **3）tryLock()**

  从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：

  - 锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；
  - 当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；
  - 其他线程持有锁：获取锁失败，返回：false；

  **4）tryLock(long timeout, TimeUnit unit)**

  逻辑和 tryLock() 差不多，只是这个方法是带时间的。

  **5）unlock()**

  释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。

  **6）newCondition**

  返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！



* **阻塞队列，例如ArrayBlockingQueue**

  在它的里面有三个关键的属性

  ```java
  // 保证并发访问的可重入锁
  final ReentrantLock lock;
  // 等待出队的条件 消费者监视器
  private final Condition notEmpty;
  // 等待入队的条件 生产者监视器
  private final Condition notFull;
  ```

* **非阻塞队列，例如ConcurrentLinkedQueue**

  底层使用的是CPU的CAS指令来保证不可中断的。

  使用的是CAS的非阻塞算法和不断重试来



## 25-公平锁和非公平锁

> ReentrantLock的默认策略就是非公平锁

* **性能方面**

  由于因为系统在唤醒线程时，会有很大的性能开销；所以如果在锁释放时，有一个线程刚好过来，对于不公平锁就会直接把锁分配给这个新的线程，这样能够使得CPU效率更高，吞吐量更大，性能更好。

  但是不公平锁可能会产生线程饥饿。



## 26-“自旋锁”详解

![](image\屏幕截图 2023-12-20 165442.png)



* **优点：**

  由于线程状态切换的开销比较大，非自旋锁切换的开销可能远远比不放弃CPU的开销要大。所以自旋锁在一定程度上可以提高系统的效率。

* **缺点：**

  如果自旋锁尝试获取锁的时间较长，开销会慢慢增加，使得开销会超过线程状态的开销。

* **使用的场景**

  所以自旋锁适用于并发度并不高的场景。

所以synchronized关键字一共有四种状态，这几个状态会随着锁的竞争逐渐升级，锁可以升级但不能降级。

无锁、偏向锁、轻量级锁（自旋锁）、重量级锁（非自旋锁）




## 27-如何合理设置线程数量

* CPU密集型任务

  比如加减幂、压缩、计算等任务比较多的情况，可以设置线程数量为**CPU核心数的一到两倍**；但是对于实际情况，我们还要考虑同一台电脑上还有哪些程序会占用CPU资源，然后对整体的资源进行一个平衡。

* IO密集型任务

  数据库的读写、网络的读写和文件的读写。这种可以设置更高的线程数。

最好的根据压力测试的结果来动态调节线程数。

**线程数 = CPU 核心数 * （1 + 平均等待时间/平均工作时间）**





## 28-CAS是一种怎么样的同步机制？

> 在高并发的业务场景下，线程安全问题是必须考虑的。在JDK5之前，可以通过synchronized和Lock来保证同步，从而达到线程安全的目的。但synchronized或Lock方案属于互斥锁的方案，比较重量级，加锁、释放锁都会引起性能消耗问题。
>
> 
>
> 而在某些场景下，我们是可以通过JUC提供的CAS机制实现无锁的解决方案，或者说它是基于类型乐观锁的方案，来达到非阻塞同步的方式保证线程安全
>
> CAS会有一个备份数据，与写操作前的拿备份数据与实际数据进行比较，是否相等，不相等就会失败，相等就执行操作。

* **什么是CAS**

  **CAS是 Compare And Swap 的缩写，直译就是比较并交换**（判断数据是否发生变化，没有发生变化就执行写操作）。CAS是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令，这个指令会对内存中的共享数据做原子的读写操作。

  其作用是让CPU比较内存中的某个值是否和预期的值相同，如果相同则将这个值更新为新的值，不相同则不做更新。

* **CAS操作**

  我们使用synchronized加锁时，是一种悲观锁策略，即认为每一次获取锁时都会发生冲突。若当前线程获取到锁，则会阻塞其他想要获取锁的线程。

  而CAS操作，又称无锁操作，是一种乐观锁策略，即认为多个线程访问共享资源时不会出现冲突。如果出现冲突，就不断的比较交换直到没有冲突为止。



### CAS有什么缺点？

* **ABA问题**

  由于判断数据的值是否变化的依据只有看数据本身是否变化，如果数据A在很短的一段时间内变成了B，然后又变回了A；这个系统就会认为这个数据A是没有发生任何变化的；这样对于某些需求肯定是不好的。

  因为CAS判断的是指针的地址，如果这个地址被重用了，问题就很大了。

  解决办法是：给数据加上版本号

* **自旋时间过长**

  CAS会配合一个循环，然后一直重试，直到能够获取到资源，但是在高并发场景性能就不好了

* **范围不能灵活控制**

  只针对某一个共享变量，不能对多个变量进行变量

  解决办法是：生成一个新的类来整合这些变量





## 29-synchronized 和 lock 的区别

| 类别     | synchronized                                                 | lock                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------ |
| 存在层次 | java的关键字，在jvm层面                                      | 是一个接口，是在代码上实现的               |
| 锁的释放 | 1、以获取锁的线程执行完同步代码，释放锁  2、线程执行发生异常，jvm会是让线程释放锁 | 在finally中必须释放锁，不然容易造成死锁    |
| 锁的获取 | 假设A线程获取锁，B线程等待。如果A线程阻塞，B线程会一直等待   | Lock有多个锁的获取的方式，可以不用一直等待 |
| 锁状态   | 无法判读                                                     | 可以判断                                   |
| 锁类型   | 可重入、不可中断、非公平                                     | 可重入、可中断、可公平                     |
| 性能     | 少量同步，性能较高                                           | 大量同步                                   |

Lock中的Condition，比如ReentrantLock提供了比Sync更精准的线程调度工具。





## 30-"RedLock"分布式锁

> 对于RedLock分布式锁，
>
> 有人质疑很有会由于NPC问题可能会造成数据异常的情况。

* **什么是NPC问题呢？会造成什么问题呢？**

  N就是network，也就是网络延迟问题；P表示进程中断；C表示时钟不一致。

  “RedLock”分布式锁是建立在同步模型的基础上的，但是实际情况是，一个系统各个子系统不能是完全是同步的。

  解决方案是增加一个逐渐递增的token。如果发生NPC问题，数据库就会拒绝token较小的写入请求。但是对资源服务器有更高的要求。

* **实际情况是**

  “RedLock”分布式锁在向其他节点申请获取锁时，会获取一个时间戳T1；如果请求同意的节点数大于设定的值时，成功获取到锁后，这时又会获取一个时间戳T2；然后进行T2 - T1 进行计算与锁的超时时间进行比较；如果超过了锁的超时时间，就释放掉锁。这样就避免了网络延迟或者时钟不一致问题。

  如果拿到锁后发生NPC问题，就很难解决了。



## 31-亿级数据过滤算法

> 10亿用户在线状态判定，如何用120M存储？

用散列表的来存储（HashMap）效率是最高的。但是存储空间如何降低到最小呢，就是用BitMap。

然后布隆过滤器就是结合了这两个结构来实现的算法。

### 布隆过滤器

> 和散列表结构一样，如果用它来存储用户在线状态，如果它不在里面，说明一定不在，如果它在里面，也有可能不在。这是一种概率的判断，即概率数据结构。

布隆过滤器的具体算法是：

当有一个用户在线后，会根据用户的标识（id或名字）进行多个hash算法计算，得到多个下标，然后将对应的byte位的数值改成1。



* **布隆过滤器的缺点**

  大小空间难以变化，无法删除数据。



* **使用场景**
  1. 在高并发场景，如果有大量的请求，容易发生缓存穿透现象。这时我们可以再缓存上使用布隆过滤器来过滤请求，如果请求数据不存在，那么就一定不存在。
  2. 处理大量数据时，就能用来过滤不存在的数据。



## 32-Redis底层数据结构之SDS（简单动态字符串）

整体结构是：头部+数据+\0

头部结构又由 `len + alloc + flag` ，组成。

len会记录数据的长度，alloc是记录数据空间剩余的空间，flag是标记数据类型（有四种，只有大小不同）

* **为什么不直接使用c中的string而是要自己实现？**

  1. 常数复杂度获取字符串。

     自身有字段存储了字符串的长度，能很大提升获取字符串长度的效率

  2. 二进制安全。

     它是以len字段来判断是否到达字符串结尾，不会让数据异常。

  3. 防止缓冲区溢出

     拼接字符串时，会根据len判断是否缓冲区溢出

  4. 减少修改字符串的内存

     c修改字符串时会释放再申请内存；而它会直接扩容为两倍

  5. 兼容部分c字符串函数

     因为以\0结尾



## 33-微服务之间是如何独立通讯的

### 同步

* **REST HTTP协议**

  1. 每个URI代表一种资源
  2. 客户端使用GET、POST、DELETE、PUT 4个表示操作方式的动词对服务端资源进行操作。
  3. 通过操作资源的表现形式来操作资源
  4. 资源表现形式是XML或者HTML
  5. 客户端与服务端之间的交互在请求之间是无状态的

* **RPC TCP协议**

  远程调用

### 异步

消息中间件，Kafka、ActiveMQ、RabbitMQ、RocketMQ；常见的协议有AMQP、MQTTP、STOMP、XMPP。





### 34-如果限流













