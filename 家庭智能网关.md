# 家庭智能网关的设计和实现

## 综合设计**II**任务简要

> 在综合设计I已完成的模块基础上，继续完善网关系统的服务层功能。在服务层的后端实现日志服务模块、账户安全服务模块、存储服务模块、音频播放模块。在完成以上服务层开发的工作量的基础上可继续完成按键交互模块、语音识别模块。
>
> 进一步的，在以上后端功能的基础上，对应实现网关的网页端控制功能，至少包括：开关机控制、日志管理、账户添加与修改、存储管理模块、音频管理模块。

较大范围的划分，可以将任务划分为三个方面：前端、后端和硬件方面。

![image-20230608154206810](C:\Users\13218\AppData\Roaming\Typora\typora-user-images\image-20230608154206810.png)

具体来说，自顶向下细分分为以下几个方面。

* **一是前端web端控制UI软件的开发。**

  具体说也就是与用户交互的web页面的开发，实现包括但不限于用户登陆和注册功能、用户添加与修改、日志查询功能、开关机控制、存储管理模块（各类存储数据的存储和如相册音频等）、能够读取删除树莓派上的文件。可以参考路由器的管理页面（实现在局域网内对树莓派进行控制）等；

​		上述的这些功能要分为两类，一类是直接的系统调用，不涉及数据库数据的交互，如开关机		控制；另一类是家庭网关实际功能的实现，涉及数据库数据交互。

涉及的知识：JSON，AJAX,HTML,JSP,CSS等

* **二是servlet层开发。**

  这是较为简单的一层，要与前端web页面交互并使用相关的业务函数实现一个个小程序来完成功能的实现。

​		涉及的知识：java web开发，HTTP协议

* **三是service层业务函数开发。**

  具体来说是与综合设计I实现的通讯功能相结合来实现代码，与前端实现功能相匹配。

  涉及的知识：TCP,java的IO流，UDP

* **四是dao层和映射文件与数据库的设计。**

  设计数据库系统然后后端通过mybatis来连接数据库进行数据的交互，我们选择的是MySQL开源的数据库来进行数据的存储管理。

​		涉及的知识：MySQL，mybatis

* **五是树莓派的部署配置。**

  利用tomcat将后端部署在服务器上，然后设置树莓派的网络。

​		涉及的知识：Linux系统、apache tomcat

* **六是树莓派的硬件的升级，如安装语音系统相关硬件等。**

下图是大概的程序流程图![image-20230608160516278](C:\Users\13218\AppData\Roaming\Typora\typora-user-images\image-20230608160516278.png)

## 家庭智能网关日志系统的设计步骤：

* **确定需求**：用户登录日志、用户操作日志（如文件的增删改查）、设备连接和断开、设备状态变化、错误信息
* **设计日志模块**：设计一个专门负责记录日志的模块，将其集成到智能网关的软件系统中。该模块一个有以下功能：
  * 日志记录：我们将记录日志信息包括：时间戳、日志级别、相关用户信息、事件描述
  * 日志存储：我们选择将日志存储在树莓派的本地文件中。
  * 日志管理：我们将只允许管理员用户对日志进行查询、导出、删除等操作。
* **实现日志记录**：我们利用java的log4j日志框架进行日志记录功能的实现，在关键的代码逻辑处插入日志记录的代码，确保关键操作的日志能够被记录下来。可以使用条件编译的方式来控制日志的级别，以便根据需要开启或关闭某些日志记录。
* **日志分析和和展示**：。。。
* **日志优化**：。。。



## 对于存储视频等特殊格式的文件的存储方式

* 第一种是文件存储+URL路径的模式
* 第二种是直接写到数据库里存放

* （ctrl + N 查看原码）

* mybatis的映射xml文件要传入多个参数可以用注解的方式

  例：xml文件

  ```xml
    <select id="getRolesByParam" resultType="priv.dengjl.ns.day0001.bean.Role">
    		select id, name, `desc` from Role where id = #{key_id} and name = #{key_name}
    </select>
  
  ```

  接口声明

  ```java
  List<Role> getRolesByParam(@Param("key_id") int id, @Param("key_name") String name);

​		

## 文件传输

* isFile判断文件是否存在

  例子：

  ```java
  @RequestMapping("/uploadFile")
      public int uploadFile(@RequestParam("uploadFile") MultipartFile file){
      	//1、判断文件是否为空
          if(file.isEmpty()){
              return null;
          }
          //2、存储的时候添上时间，防止文件名重复
          Date date = new Date();
          SimpleDateFormat dateFormat= new SimpleDateFormat("yyyyMMddhhmmss");
          String fileName = dateFormat.format(date) + "_" + file.getOriginalFilename();
          //文件实际存储地址，以linux系统为标杆
          String filePath =  "/javaweb/tomcat/apache-tomcat-8.5.41/webapps/resources/";
          //可供下载的链接地址，将ip替换为你自己的ip即可，resources文件夹的位置很重要，不同的位置，可供下载的链接地址也就不一样。，可参考文件实际存储地址来设。
          String fileLink = "http://0.0.0.0:8080/resources/" + fileName;
          File dest = new File(filePath + fileName);
          try {
              file.transferTo(dest);
          }catch (IOException e){
              e.printStackTrace();
              return "500";
          }
          return "200"
  
      }
  
  ```

  

`part.getSize()` 是一个用于获取上传文件大小的方法，其中 `part` 是 Servlet 3.0 开始提供的用于表示 HTTP multipart 请求的一部分的接口。如果上传文件的内容大于限制的最大大小，则会抛出异常。
使用此方法，您可以获取用户上传文件的大小，并根据需要执行适当的操作，例如响应“文件过大”消息截断文件。
用法示例：

```java
javaCopy codeprotected void doPost(HttpServletRequest request, HttpServletResponse) throws ServletException, IOException {
  String filename = null;
  Part filePart = request.getPart("file"); // 获取上传文件
  long fileSize = filePart.getSize(); // 获取上传文件大小，单位为字节
  if (fileSize > MAX_FILE_SIZE) { // 如果文件大小大于最大限制
    // 返回错误响应消息
    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "文件超过最大限制");
    return;
  }
  // 保存文件到指定路径
  InputStream fileContent =Part.getInputStream();
  filename = "yourfilenamehere";
  // ...
}
```

在上示例中，我们首先通过 `request.getPart()` 获取上传的文件的 `Part` 对象，然后使用 `getSize()` 方法获取文件的大小。如果文件大小超过了所设置的最大值，则返回一个错误响应消息。否则，我们可以将文件保存到指定的路径中。
需要注意的是，文件大小的单位是字节。如果您需要将文件大小转换为 KB 或 MB 等其他单位，可以使用常规的字节单位换方法进行转换。

`part.write(fileURL)` 是 `Part` 接口中的一个方法，用于将上传的文件写入指定的文件路径。
下面是一个使用 `part.write(fileURL)` 方法将上传文件写入指定文件路径的示例代码：

```java
javaCopy codeprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    Part filePart = request.getPart("file"); // 获取上传的文件
    String fileName = filePart.getSubmittedFileName(); // 获取上传的文件名
    
    // 指定文件保存的路径
    String fileURL = "/path/to/your/file/directory/" + fileName;
    
    // 将文件写入指定的文件路径
    filePart.write(fileURL);
    
    // 其他处理逻辑...
}
```

在上述示例中，我们首先通过 `request.getPart("file")` 获取上传的文件的 `Part` 对象，然后通过 `getSubmittedFileName()` 方法获取上传的文件名。接下来，我们指定了文件保存的路径 `fileURL`。最后，通过调用 `write(fileURL)` 方法，将上传的文件内容写入指定的文件路径中。
需要注意的是，要保证指定的文件路径存在，并且具有写入权限。另外，如果指定的文件路径已经存在同名文件，`write(fileURL)` 方法将会覆盖该文件，所以在使用此方法时要注意慎重处理。

## Filter

```xml
<filter>
        <filter-name>LoginFilter</filter-name>
        <filter-class>com.filter.LoginFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>LoginFilter</filter-name>
        <url-pattern>/protected</url-pattern>
    </filter-mapping>
```

* 要把三个方法否实现，否则服务器启动会出现错误

* 到tomcat安装目录的conf中的web.xml中配置<welcome-file-list>标签可以设置初始页面

* Could not find resource sqlMapconfig.xml：

​		文件名错误了

## Mybatis配置

 配置约定资源位置（ Could not find resource com/dao/WebDao.xml）

```xml
 <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

```

在web.xml文件中配置

```xml
        <multipart-config>
            <max-file-size>20848820</max-file-size>
            <max-request-size>418018841</max-request-size>
            <file-size-threshold>1048576</file-size-threshold>
        </multipart-config>
```

fileSizeThershold         int型      是（可选）     描述：当前数据量大于该值时，内容将被写入文件。

location               String型           是（可选）     描述：存放生成文件的地址

maxFileSize        long型             是（可选）     描述：允许上传的文件最大值，默认为-1，表示没有限制

maxRequestSize    long型         是（可选）     描述：针对 multipart/form-data 请求的最大数量，默认为-1，表示没有限制



### java的字符串处理工具

```txt
StringUtils.substringBefore(“dskeabcee”, “e”);

/结果是：dsk/

这里是以第一个”e”，为标准。

StringUtils.substringBeforeLast(“dskeabcee”, “e”)

结果为：dskeabce

这里以最后一个“e”为准。
```



```xml
<dependency>
<groupId>commons-lang</groupId>
<artifactId>commons-lang</artifactId>
<version>2.6</version>
</dependency>
```

