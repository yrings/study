# 第八章 分布式锁

> 分布式锁是控制分布式系统间同步访问共享资源的一种方式，其可以保证共享资源在并 发场景下的数据一致性

## 分布式锁的原理

> 分布式锁应用场景，当多个请求同一时间对某个共享资源进行访问时，为了达到同步访问的目的，需要先申请一个 **token（令牌）**，这个token是互斥资源。只有获取到这个 token 的请求才能访问资源。
>
> 而这个token就是通过各种技术实现的分布式锁。

模拟秒杀商品的场景:

```java
@Autowired
private StringRedisTemplate srt;

@GetMapping("sk")
public String seckillHandler(){
    //从Redis中获取库存
    String stock = srt.opsForValue().get("sk:0008");
    //将字符串形式的十进制数转化成int类型
    int amount = stock == null ? 0 :Integer.parseInt(stock);
    if (amout > 0) {
        //修改库存后再写Redis
        srt.opsForValue().set("sk:0008",String.ValueOf(--amout));
        return "库存剩余" + amount + "台";
    }
    return "抱歉，你没有抢到"
}
```

如果用`synchronize(this)`来将业务代码进行同步处理，由于在实际的问题中，一般是由多个服务器来同时处理多个请求的，如果单纯地用同步代码块来处理，多个请求也能在同一时间被处理。



先在要模拟一个多服务的客户端，分别用不同的端口号来表示不同的服务器，然后用`Nginx`  负载均衡到三个主机，然后三个主机共享一个Redis。

设置允许多实例运行：

![](image\屏幕截图 2023-10-15 220548.png)





## JMeter压测工具

略

## setnx 实现分布式锁

> setnx 是用来创建或设置key的值的，只有当key不存在时，才能执行成功。
>
> zookeeper也能实现。。。
>
> DBMS也能实现，在访问共享资源时，要在表中插入一个指定值的主键，因为主键是唯一的，只有成功插入的才能访问资源。操作完毕后再将插入的数据删除。

 ```java
 @Autowired
 private StringRedisTemplate srt;
 
 @GetMapping("/sk2")
     public String seckillHandler2(){
         String result = "抱歉，你没有抢到";
         try {
             //添加锁
             Boolean lockOK = srt.opsForValue().setIfAbsent(REDIS_LOCK, "I'm a lock");
             if (!lockOK) {
                 return result;
             }
             //从Redis中获取库存
             String stock = srt.opsForValue().get("sk:0008");
             stock = stock.replace("\n", "");
             //将字符串形式的十进制数转化成int类型
             int amount = stock == null ? 0 : Integer.parseInt(stock);
             if (amount > 0) {
                 //修改库存后再写Redis
                 srt.opsForValue().set("sk:0008", String.valueOf(--amount));
                 result = "库存剩余" + amount + "台";
                 System.out.println(result);
             }
         } finally {
             srt.delete(REDIS_LOCK);
         }
         return result + "server is " +  serverPort;
     }
 ```

仍存在的问题，当在代码执行过程中宕机了，锁无法删除。系统就一直阻塞。

**解决方法：设置过期时间**

```java
// 为锁添加过期时间
srt.expire(REDIS_LOCK,5, TimeUnit.SECONDS);
```

这样设置的话，有可能在设置过期时间之前就宕机的话，就还是没有解决问题。

**解决方法：在创建时就设置过期时间,这样具有原子性**

```java
//添加锁并设置过期时间
Boolean lockOK = srt.opsForValue().setIfAbsent(REDIS_LOCK, "I'm a lock" ,5, TimeUnit.SECONDS);
```

但是又出现了问题，如果执行时间大于过期时间，使得另一个请求申请到锁进入业务代码，然后先前的请求又会删除掉后一个请求的锁，又会有新的请求进来。。。

**解决方法：为锁添加客户端标识，使得锁只能由申请锁者来删除**

```java
String clientId = UUID.randomUUID().toString();
....
//将锁的值设置为UUID
Boolean lockOK = srt.opsForValue().setIfAbsent(REDIS_LOCK, clientId ,5, TimeUnit.SECONDS);
....
if(srt.opsForValue().get(REDIS_LOCK).equals(clientId)){
	srt.delete(REDIS_LOCK);
}
```

但又有新的问题出现了，当在进入锁是否为同一个锁的判断语句时，将要释放锁时，这时恰好过期时间到了，并且又有另一个请求申请到了锁，这时前一个请求就会删除掉后一个请求的锁。

这两串代码不具有原子性。

**解决方法：一种是事务，使两串代码具有原子性；第二种是用lua脚本,因为lua脚本具有原子性**

第二种，要用到`Jedis`相关依赖

```xml
<dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>4.2.0</version>
        </dependency>
```

用Redis的`eval script numkeys key [key ...] arg [arg ...]`

- `script`： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。
- `numkeys`： 用于指定键名参数的个数。

* `key [key …]`： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。
* `arg [arg …]`： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。

```java
JedisPool jedisPool = new JedisPool(redishost,redisport);
            try(Jedis jedis =jedisPool.getResource()){
                // 定义Lua脚本，注意，每行最候要有一个空格
                // redis.call() 是lua中对Redis命令的调用函数
                String script = "if redis.call('get',KEYS[1] == ARGV[1]) " +
                                "then return redis.call('del', KEYS[1]) " +
                                "end " +
                                "return 0";
                // eval() 方法的返回值为脚本script的返回值
                Object eval = jedis.eval(script, Collections.singletonList(REDIS_LOCK),Collections.singletonList(clientId));
                if("1".equals(eval.toString())){
                    System.out.println("释放锁成功");
                } else {
                    System.out.println("释放锁时发生异常");
                }
            }
```

但是执行时间大于过期时间的问题仍然没有解决（锁会过期，有新的请求进来）；

**解决方法：锁续约，或锁续命。既`fork()`一个子进程，然后设置一个定时任务（定时间隔要小于键的过期时间），检查锁是否存在。如果锁不存在且在过期时间内，说明执行时间小于过期时间，就自己结束子进程；如果锁还存在，就会延长过期时间，即“续命”。**

这时就有一个框架来解决这种问题即，**Redisson**

## Redisson 可重入锁

### 原理

> Redisson 内部使用 Lua 脚本实现了对可重入锁的添加、重入、续约（续命）、释放。
>
> Redisson 需要用户为锁指定一个 key，但无需为锁指定过期时间，因为它有默认过期时间(当然，也可指定)。由于该锁具有“可重入”功能，所以 Redisson 会为该锁生成一个计数器，记录一个线程重入锁的次数。 
>
> 
>
> 如何识别锁呢？指定了key，然后这个锁的value类型是一个hash， 它的field是当前线程的threadID，value为计数器，只有当value值为0时才能被删除



Redisson 依赖

```xml
<dependency>
 <groupId>org.redisson</groupId>
 <artifactId>redisson</artifactId>
 <version>3.17.6</version>
</dependency>
```



### 应用

首先，先将Redisson放入`IOC`容器中,在启动类中配置

```java
@Value("${spirng.data.redis.password}")
    private String redisPassword;

    @Value("${spring.data.redis.host}")
    private String redisHost;

    @Value("${spring.data.redis.port}")
    private int redisPort;

    @Bean
    public Redisson redisson() {
        Config config = new Config();
        config.useSingleServer()
                .setAddress(redisHost + ":" + redisPort)
                .setDatabase(0)
                .setPassword(redisPassword);
        return (Redisson) Redisson.create();
    }
```

然后在业务中实现

```java
@Autowired
    private Redisson redisson;

@GetMapping("/sk4")
    public String seckillHandler4(){
        String result = "抱歉，你没有抢到";
        RLock rLock = redisson.getLock(REDIS_LOCK);

        try {
            //利用Redisson添加分布式锁
            Boolean lockOK = rLock.tryLock();

            if (!lockOK) {
                return result;
            }
            //从Redis中获取库存
            String stock = srt.opsForValue().get("sk:0008");
            stock = stock.replace("\n", "");
            //将字符串形式的十进制数转化成int类型
            int amount = stock == null ? 0 : Integer.parseInt(stock);
            if (amount > 0) {
                //修改库存后再写Redis
                srt.opsForValue().set("sk:0008", String.valueOf(--amount));
                result = "库存剩余" + amount + "台";
                System.out.println(result);
            }
        } finally {
            //释放锁
            rLock.unlock();
        }
        return result + "server is " +  serverPort;
    }
```

在 Redisson 源码中，如果在申请锁时被占用会直接拒绝掉请求。

所以可以修改`tryLock()的参数来设置请求等待`

```java
//利用Redisson添加分布式锁
//Boolean lockOK = rLock.tryLock();
// 指定锁的过期时间为 5 秒，如果申请失败。则最长等待20秒
Boolean lockOK = rLock.tryLock(20, 5, TimeUnit.SECONDS);
```

存在问题解析：

若redis跑在高可用的主从集群上，当有一个请求申请锁后，在master节点上向其返回了一个加锁成功的信息，在master向其它 slave 同步数据完成之前，发生了宕机；然后有新的 master 晋升之后，又来了一个请求申请锁，这时新的 master 没有之前已经有锁的信息，会同意锁的申请。这时就发生了多个请求同时访问共享数据，可能会导致数据的不一致。

这个问题是 Redis 集群本身的AP性质导致的问题。



解决方法： 利用 **Redisson 红锁**



## Redisson 红锁

>  Redisson 红锁（RedLock）可以防止主从集群锁丢失问题。Redisson 红锁要求，必须要构建出至少三个 Redis 主从集群。若一个请求要申请锁，必须向所有主从集群中提交 key 写入请求，只有 当大多数集群锁写入成功后，该锁才算申请成功。



实际应用：

在启动类中，配置三个锁

```java
@Bean("redisson-1")
    public Redisson redisson1() {
        Config config = new Config();
        config.useSentinelServers()
                .setMasterName("mymaster1")
                .addSentinelAddress("redis:16380","redis:16381","redis:16382");
        return (Redisson) Redisson.create();
    }

	...
```

在业务代码中：

```java
@Resource(name = "redisson-1")
private Redisson redisson1;

...

 @GetMapping("/sk4")
    public String seckillHandler4(){
        String result = "抱歉，你没有抢到";
        // 定义三个可重入锁
        RLock rLock1 = redisson1.getLock(REDIS_LOCK + "-1");
        RLock rLock2 = redisson2.getLock(REDIS_LOCK + "-2");
        RLock rLock3 = redisson3.getLock(REDIS_LOCK + "-3");

        // 定义红锁
        RLock rLock = new RedissonRedLock(rLock1,rLock2,rLock3);
        
       ....
```



## 分段锁优化性能

> 无论前面使用的是哪种锁，他们解决并发问题的思路都是相同的，那就是将所有请求通过加锁实现**串行化**。而串行化在高并发场景下势必会引发性能问题。



这时可以通过**分段锁**来优化性能。

分段锁就是使访问并行化，将要共享访问的一个资源拆分为多个共享访问资源，这样就会把一把锁的需求转变为多把锁，实现并行化。

例如，对于秒杀商品 sk:0008，其有 1000 件。现在将其拆分为 10 份，每份 100 件。即 将秒杀商品变为了 10 件，分别为 sk:0008:01，sk:0008:02，sk:0008:03，„„，sk:0008:10。 这样的话，就需要 10 把锁来控制所有请求的并发。由原来的因为只有一把锁而导致的每个 时刻只能处理 1 个请求，变为了现在有了 10 把锁，每个时刻可以同时处理 10 个请求。并发 提高了 10 倍。



## Redisson 详解

> Redisson 是一个在Redis 的基础上实现的 java 驻内存数据网格它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务。
>
> 在生产中，对于 Redisson 使用最多的场景就是其分布式锁 RLock。当然，RLock 仅仅是 Redisson 的线程同步方案之一。**Redisson 提供了 8 种线程同步方案**，用户可针对不同场景选 用不同方案。 
>
> 需要注意的是，为了避免锁到期但业务逻辑没有执行完毕而引发的多个线程同时访问共 享资源的情况发生，Redisson 内部为锁提供了一个监控锁的看门狗 **watch dog**，其会在锁到 期前不断延长锁的到期时间，直到锁被主动释放。即会自动完成“锁续命”。

Redisson 底层采用的是 Netty 框架。支持 Redis2.8 以上版本，支持 Java1.6+以上版本

Redisson 官网：https://redisson.org，github 上的官网：https://github.com/redisson/redisson。

可以在github官网上的Wiki部分查看中文文档。

在生成环境下常用的**8种线程同步方法**。

### 可重入锁（Reentrant Lock）

> Redisson 的分布式锁 RLock 是一种可重入锁，当一个线程获取 本对象上的锁，而其它的线程是不可以的。
>
> JDK 中的ReentrantLock 是可重入锁，其是通过 AQS 实现的锁机制。
>
> synchronize 也是可重入锁，其是通过**监视器模式（本质是 OS 的互斥锁）**实现的锁机制,这个实现会对性能有影响。

**AQS：是JDK1.5提供的一个基于FIFO等待队列实现的一个用于实现同步器的基本框架。**

### 公平锁（Fair Lock）

> Redisson 的可重入锁 RLock 默认是一种非公平锁，但也支持可重入公平锁 FailLock。当 有多个线程同时申请锁时，这些线程会进入到一个 FIFO 队列，只有队首元素才会获取到锁， 其它元素等待。只有当锁被释放后，才会再将锁分配给当前的队首元素

### 联锁（MultiLock）

> Redisson 分布式锁可以实现联锁 MultiLock。当一个线程需要同时处理多个共享资源时， 可使用联锁。即一次性申请多个锁，同时锁定多个共享资源。联锁可预防死锁。相当于对共享资源的申请实现了原子性：要么都申请到，只要缺少一个资源，则将申请到的所有资源全 部释放。其是 OS 底层原理中 AND 型信号量机制的典型应用

### 红锁（RedLock）

> Redisson 分布式锁可以实现红锁 RedLock。红锁由多个锁构成，只有当这些锁中的大部 分锁申请成功时，红锁才申请成功。红锁一般用于解决 Redis 主从集群锁丢失问题。 
>
> 红锁与联锁的区别是，红锁实现的是对一个共享资源的同步访问控制，而联锁实现的是 多个共享资源的同步访问控制

### 读写锁（ReadWriteLock）

> 通过 Redisson 可以获取到读写锁 RReadWriteLock。通过 RReadWriteLock 实例可分别获 取到读锁 RedissonReadLock 与写锁 RedissonWriteLock。读锁与写锁分别是实现了 RLock 的可 重入锁。 
>
> 一个共享资源，在没有写锁的情况下，允许同时添加多个读锁。只要添加了写锁，任何 读锁与写锁都不能再次添加。即读锁是共享锁，写锁为排他锁

### 信号量（Semaphore）

> 通过Redisson可以获取到信号量RSemaphore。RSemaphore的常用场景有两种：
>
> * 一种是， 无论谁添加的锁，任何其它线程都可以解锁，就可以使用 RSemaphore。这种就是互斥信号量。
>
> * 另外，当一个线程 需要一次申请多个资源时，可使用 RSemaphore。在HYSTRIX中，就使用了信号量执行隔离策略。
>
>   RSemaphore 是信号量机制的典型应用

用Redisson实现多资源信号量：

对信号量的PV操作是具有原子性的

```java
//redis_semaphore是redis随意写入的键，值为5
RSemaphore rs = redisson,getSemaphore("redis_semaphore");
try{
    // 申请1个信号量，即信号量减1
    rs.acquire();
    // 一次申请3个信号量，若没有申请成功，最多等待10秒
    rs.tryAcquire(3, 10, TimeUnit.SECONDS);
} catch(Exception e){
    ...
} finally{
    // 释放3个资源
    rs.release(3);
}
```

### 可过期性信号量（PermitExpirableSemaphore）

> 通过 Redisson 可以获取到可过期信号量 PermitExpirableSemaphore。该信号量是在 RSemaphore 基础上，为每个信号增加了一个过期时间，且每个信号都可以通过独立的 ID 来 辨识。释放时也只能通过提交该 ID 才能释放。 
>
> 不过，一个线程每次只能申请一个信号量，当然每次了只会释放一个信号量。这是与 RSemaphore 不同的地方。 
>
> 该信号量为互斥信号量时，其就等同于可重入锁。或者说，可重入锁就相当于信号量为 1 的可过期信号量。

### 闭锁（CountDownLatch）

> 通过 Redisson 可以获取到分布式闭锁 RCountDownLatch，其与 JDK 的 JUC 中的闭锁 CountDownLatch 原理相同，用法类似。其常用于一个或者多个线程的执行必须在其它某些 任务执行完毕的场景。例如，大规模分布式并行计算中，最终的合并计算必须基于很多并行计算的运行完毕。 
>
> 闭锁中定义了一个计数器和一个阻塞队列。阻塞队列中存放着待执行的线程。每当一个 并行任务执行完毕，计数器就减 1。当计数器递减到 0 时就会唤醒阻塞队列的所有线程。 
>
> 通常使用 Barrier 队列解决该问题，而 Barrier 队列通常使用 Zookeeper 实现

