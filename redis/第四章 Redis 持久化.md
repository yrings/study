# 第四章 Redis 持久化

> Redis 是一个内存数据库，所以其运行效率非常高。但也存在一个问题；内存中的数据是不持久的，若主机宕机或Redis 关机重启，则内存中的数据全部丢失。当然，这是不允许的。Redis持久化功能，其会按照设置以**快照**或**操作日志**的形式将数据持久化到磁盘。
>
> Redis的持久化分为两种：RDB 与 AOF。

![](image\屏幕截图 2023-10-06 180322.png)

RDB是默认持久化方式，但Redis允许RDB与AOF两种持久化技术同时开启，此时系统会使用AOF方式做持久化，即AOF持久化技术的优先级要更高。同样的道 理，两种技术同时开启状态下，系统启动时若两种持久化文件同时存在，则优先加载 AOF 持久化文件。

## RDB持久化

> RDB,Redis DataBase ，是指将内存中某一时刻的数据快照全量写入到指定的rdb文件的持久化技术。RDB持久化默认是开启的。当Redis启动时会自动读取RDB快照文件，将数据从硬盘载入到内存，以恢复Redis关机前的数据库状态。

### RDB持久化的执行

**RDB 持久化的执行有三种方式：手动 save 命令、手动 bgsave 命令，与自动条件触发。** 

**（1） 手动 save 命令 **

通过在 redis-cli 客户端中执行 save 命令可立即进行一次持久化保存。save 命令在执行期 间会阻塞 redis-server 进程，直至持久化过程完毕。而在 redis-server 进程阻塞期间，Redis 不能处理任何读写请求，无法对外提供服务。 

**（2） 手动 bgsave 命令 **

通过在 redis-cli 客户端中执行 bgsave 命令可立即进行一次持久化保存。不同于 save 命 令的是，正如该命令的名称一样，background save，后台运行 save。bgsave 命令会使服务器 进程 redis-server 生成一个子进程，由该子进程负责完成保存过程。在子进程进行保存过程 中，不会阻塞 redis-server 进程对客户端读写请求的处理

**（3）自动条件触发**

自动条件触发的本质仍是 bgsave 命令的执行。只不过是用户通过在配置文件中做相应 的设置后，Redis 会根据设置信息自动调用 bgsave 命令执行。具体配置方式，后面会详解。

**（4）查看持久化时间**

通过 lastsave 命令可以查看最近一次执行持久化的时间，其返回值是一个Unix时间戳

### RDB 优化配置

> RDB 相关的配置在redis.conf  文件的 SNAPSHOTTING 部分

**（1） save**

![](image\屏幕截图 2023-10-06 181546.png)

该配置用于设置快照的自动保存触发条件，即 save point，保存点。该触发条件是在指 定时间段内发生了指定次数的写操作。除非另有规定，默认情况下持久化条件为 save 3600 1  300 100 60 10000。其等价于以下三条： 

* save 3600 1 # 在 3600 秒(1 小时)内发生 1 次写操作 

* save 300 100 # 在 300 秒(5 分钟)内发生 100 次写操作 

* save 60 10000 # 在 60 秒(1 分钟)内发生 1 万次写操作 

  如果不启用 RDB 持久化，只需设置 save 的参数为空串即可：save “”

**（2）stop-write-on-bgsave-error**

默认情况下，如果RDB快照已启用（至少一个保存点），且最近的bgsave命令失败，Redis将停止接收写入。这样设置是为了让用户意识到数据没有正确地保存到磁盘上，否则可能没有人会注意到。当bgsave命令后来可以正常工作了，Redis将自动允许再次写入。

**（3）rdbcompresssion**

当进行持久化时启用 LZF 压缩字符串对象。虽然压缩 RDB 文件会消耗系统资源，降低性 能，但可大幅降低文件的大小，方便保存到磁盘，加速主从集群中从节点的数据同步。

> lzf压缩算法是一种非常高效的压缩算法，它可以在保证压缩效率的同时，降低压缩和解压缩的时间成本。lzf压缩算法的原理是基于一种叫做“sliding window”（滑动窗口）的算法。具体来说，lzf算法先利用滑动窗口将输入分成多个片段，然后对每个片段进行压缩。

**（4）rdbchecksum**

从 RDB5 开始，RDB 文件的 CRC64 校验和就被放置在了文件末尾。这使格式更能抵抗 RDB 文件的损坏，但在保存和加载 RDB 文件时，性能会受到影响（约 10%），因此可以设置为 no 禁用校验和以获得最大性能。在禁用校验和的情况下创建的 RDB 文件的校验和为零，这将 告诉加载代码跳过校验检查。默认为 yes，开启了校验功能。

**（5） sanitize-dump-payload**

该配置用于设置在加载 RDB 文件或进行持久化时是否开启对 zipList、listPack 等数据的 全面安全检测。该检测可以降低命令处理时发生系统崩溃的可能。其可设置的值有三种选择： 

* no：不检测 

* yes：总是检测 

* clients：只有当客户端连接时检测。排除了加载 RDB 文件与进行持久化时的检测。 

  默认值本应该是 clients，但其会影响 Redis 集群的工作，所以默认值为 no，不检测

**（6）dbfilename**

指定RDB文件的默认名称，默认为dump.rdb

**(7) rdb-del-sync-files**

主从复制时，是否删除用于同步的从机上的 RDB 文件。默认是 no，不删除。不过需要 注意，只有当从机的 RDB 和 AOF 持久化功能都未开启时才生效。

**(8)dir**

指定RDB与AOF文件的生存目录。默认为Redis的安装目录。

### RDB 文件结构

![](image\屏幕截图 2023-10-07 163101.png)

**（1）SOF**

SOF 是一个常量，一个字符串`REDIS`，仅包含这个五个字符，其长度为5.用于标识RDB文件的开始，以便在加载RDB文件时可以迅速判断出文件是否是RDB文件。

**（2）rdb_version**

这是一个整数，长度为4字节，表示RDB文件的版本号

**（3）EOF**

EOF是一个常量，占1个字节，用于标识RDB数据的结束，校验和的开始。

**（4）check_sum**

校验和check_sum用于判断RDB文件的内容是否出现数据异常。采用的是CRC校验算法。

这种验证算法，是数据损坏校验，而不是数据没有损坏的校验

**（5）databases**

![](image\屏幕截图 2023-10-07 164041.png)

databases 部分是 RDB 文件中最重要的数据部分，其可以包含任意多个非空数据库。而 每个 database 又是由三部分构成： 

* SODB：是一个常量，占 1 个字节，用于标识一个数据库的开始。 
* db_number：数据库编号。 
* key_value_pairs：当前数据库中的键值对数据。

![](image\屏幕截图 2023-10-07 164146.png)

每个 key_value_pairs 又由很多个用于描述键值对的数据构成。 

* VALUE_TYPE：是一个常量，占 1 个字节，用于标识该键值对中 value 的类型。 
* EXPIRETIME_UNIT：是一个常量，占 1 个字节，用于标识过期时间的单位是秒还是毫秒。 
* time：当前 key-value 的过期时间

### RDB 持久化过程

​	对于Redis默认的RDB持久化，在进行bgsave持久化时，redis-server进程会fork出一个bgsave子进程，由该子进程以异步方式负责完成持久化。而在持久化过程中，redis-server进程不会阻塞。

​	bgsave子进程的详细工作原理如下：

​	由于子进程可以继承父进程的所有资源，且父进程不能拒绝子进程的继承权。所以，bgsave 子进程有权读到redis-server进程写入到内存中的用户数据。

​	**bgsave子进程在持久化时首先会将内存中的全量数据copy到磁盘中的一个RDB临时文件，copy结束后，再将该文件改名为dump.rdb，替换掉原来的同名文件。**

​	不过，在进行持久化过程中，如果redis-server进程接收到了用户写请求，则系统会将内存中发生数据修改的物理块copy出一个副本。等内存中的全量数据copy接收后，再将副本中的数据copy到RDB临时文件。

这个副本的生成是由于Linux系统的**写时复制技术（Copy-On-Write）**实现的

![](image\屏幕截图 2023-10-07 165234.png)

> **写时复制技术：**
>
> 写时复制技术是Linux系统的一种进程管理技术。
>
> 原本在Unix系统中，当一个主进程通过fock()系统调用创建子进程后，内核进程会复制整个内存空间的数据，然后分配给子进程。这种方式有一下的缺点：
>
> 1. 这个过程非常耗时，降低了系统的性能
> 2. 如果主进程修改了其内存数据，子进程副本中的数据是没有修改的，导致数据一致性无法保证。
>
> 现代的Linux则采用了更为有效的方式：写时复制。即子进程会继承父进程的资源，共享内存空间。只要内存被共享，内存就是只读（写保护的）。而写时复制则是在任意一方需要写入数据到共享内存中时，都会出现异常，此时内核进程就会将需要写入内存的数据copy出一个副本写入到另一块非共享内存区域

## AOF 持久化

> AOF，Append Only File，是指 Redis 将每一次的写操作都以日志的形式记录到一个 AOF 文件中的持久化技术。当需要恢复内存数据时，将这些写操作重新执行一次，便会恢复到之 前的内存数据状态。

### AOF 基础配置

**（1）AOF 的开启**

默认情况下AOF持久哈是没有开启的，通过修改配置文件中的appendonly属性为yes可以开启。

**（2）文件名配置**

![](image\屏幕截图 2023-10-07 170152.png)

Redis 7 在这里发生了重大变化。原来只有一个appendonly.aof文件，现在具有了三类多个文件。

* 基本文件：可以是 RDB 格式也可以是 AOF 格式。其存放的内容是由 RDB 转为 AOF 当 时内存的快照数据。该文件可以有多个。 
* 增量文件：以操作日志形式记录转为 AOF 后的写入操作。该文件可以有多个。 
* 清单文件：用于维护 AOF 文件的创建顺序，保障激活时的应用顺序。该文件只有一个。

**（3）混合式持久化开启**

对于基本文件可以是 RDB 格式也可以是 AOF 格式。通过 `aof-use-rdb-preamble` 属性可以 选择。其默认值为 yes，即默认 AOF 持久化的基本文件为 rdb 格式文件，也就是默认采用混合式持久

**(4) AOF 文件目录配置**

为了方便管理，可以专门为 AOF 持久化文件指定存放目录。目录名由 appenddirname 属性指定，存放在 redis.conf 配置文件的 dir 属性指定的目录，默认为 Redis 安装目录

### AOF 文件格式

> AOF 文件包含三类文件：基本文件、增量文件与清单文件。其中基本文件一般为 rdb 格 式，在前面已经研究过了。下面就来看一下增量文件与清单文件的内容格式。

**(1) Redis 协议**

增量文件扩展名为.aof，采用 AOF 格式。AOF 格式其实就是 Redis 通讯协议格式，AOF 持久化文件的本质就是基于 Redis 通讯协议的文本，将命令以纯文本的方式写入到文件中。 

Redis 协议规定，Redis 文本是以行来划分，每行以\r\n 行结束。每一行都有一个消息头， 以表示消息类型。消息头由六种不同的符号表示，其意义如下： 

* +) 表示一个正确的状态信息 
* (-) 表示一个错误信息 
* (*) 表示消息体总共有多少行，不包括当前行 
* ($) 表示下一行消息数据的长度，不包括换行符长度\r\n 
* (空) 表示一个消息数据 
* (:) 表示返回一个数值

**（2）查看AOF文件**

 打开 `appendonly.aof.1.incr.aof`文件，可以看到如下格式内容。

![](image\屏幕截图 2023-10-07 171203.png)

**（3）清单文件**

打开清单文件`apendonly.mainfest`查看其内容如下：

![](image\屏幕截图 2023-10-07 171358.png)

该文件首先会按照 seq 序号列举出所有基本文件，基本文件 type 类型为 b，然后再按照 seq 序号再列举出所有增量文件，增量文件 type 类型为 i。 

对于 Redis 启动时的数据恢复，也会按照该文件由上到下依次加载它们中的数据

### Rewrite 机制

> 随着使用时间的推移，AOF文件会越来越大。为了防止AOF文件由于太大而占用大量的磁盘空间，降低性能，Redis引入了Rewrite机制来对AOF文件进行压缩。

**（1）什么是rewrite**

所谓Rewrite其实就是对AOF文件进行重写整理。当Rewrite开启后，主进程redis-server创建出一个子进程`bgrewriteaof `,有该子进程完成rewrite过程。其首先对现有aof文件进行**rewrite计算**，将计算结果写入到一个临时文件，写入完毕后，再rename该临时文件为原aof文件名，覆盖其。

**（2）rewrite计算**

rewrite 计算也称为 rewrite 策略。rewrite 计算遵循以下策略： 

* 读操作命令不写入文件 
* 无效命令不写入文件 
* 过期数据不写入文件 
* 多条命令合并写入文件

**（3）手动开启rewrite**

Rewrite 过程的执行有两种方式。一种是通过 `bgrewriteaof `命令手动开启，一种是通过 设置条件自动开启

**（4）自动开启rewrite**

* `auto-aof-rewrite-percentage`：开启 rewrite 的增大比例，默认 100%。指定为 0，表示禁 用自动 rewrite。 

* `auto-aof-rewrite-min-size`：开启 rewrite 的 AOF 文件最小值，默认 64M。该值的设置主 要是为了防止小 AOF 文件被 rewrite，从而导致性能下降。 

  自动重写 AOF 文件。当 AOF 日志文件大小增长到指定的百分比时，Redis 主进程 redis-server 会 fork 出一个子进程 `bgrewriteaof `来完成 rewrite 过程

​	其工作原理如下：Redis 会记住最新 rewrite 后的 AOF 文件大小作为基本大小，如果从主 机启动后就没有发生过重写，则基本大小就使用启动时 AOF 的大小。 如果当前 AOF 文件大于基本大小的配置文件中指定的百分比阈值，且当前 AOF 文件大 于配置文件中指定的最小阈值，则会触发 rewrite。

### AOF 优化配置

**（1）appendfsync**

​	当客户端提交写操作命令后，该命令就会写入到 aof_buf 中，而 aof_buf 中的数据持久 化到磁盘 AOF 文件的过程称为数据同步。 

何时将 aof_buf 中的数据同步到 AOF 文件？采用不同的数据同步策略，同时的时机是不同的，有三种策略： 

* always：写操作命令写入 aof_buf 后会立即调用 fsync()系统函数，将其追加到 AOF 文件。 该策略效率较低，但相对比较安全，不会丢失太多数据。最多就是刚刚执行过的写操作 在尚未同步时出现宕机或重启，将这一操作丢失。 
* no：写操作命令写入 aof_buf 后什么也不做，不会调用 fsync()函数。而将 aof_buf 中的 数据同步磁盘的操作由操作系统负责。Linux 系统默认同步周期为 30 秒。效率较高。 
* everysec：默认策略。写操作命令写入 aof_buf 后并不直接调用 fsync()，而是每秒调用 一次 fsync()系统函数来完成同步。该策略兼顾到了性能与安全，是一种折中方案

**（2）no-appendfsync-on-rewrite**

​	该属性用于指定，当 AOF fsync 策略设置为 always 或 everysec，当主进程创建了子进程 正在执行 bgsave 或 bgrewriteaof 时，主进程是否不调用 fsync()来做数据同步。设置为 no， 双重否定即肯定，主进程会调用 fsync()做同步。而 yes 则不会调用 fsync()做数据同步。 

​	如果调用 fsync()，在需要同步的数据量非常大时，会阻塞主进程对外提供服务，即会存 在延迟问题。如果不调用 fsync()，则 AOF fsync 策略相当于设置为了 no，可能会存在 30 秒 数据丢失的风险

**（3）aof-rewrite-incremenetal-fsync**

![](image\屏幕截图 2023-10-07 174105.png)

​	当bgrewriteaof在执行过程也是先将rewrite计算的结果写入到了`aof_write_buf`缓存中，然后当缓存中数据达到一定量后就会调用fsync()进行刷盘操作，即数据同步，将数据写入到临时文件。该属性用于控制fsync()每次刷盘的数据量最大不超过**4MB**。可以避免由于单次刷盘量过大而引发长时间阻塞。

**（4）aof-load-truncated**

在进行 AOF 持久化过程中可能会出现系统突然宕机的情况，此时写入到 AOF 文件中的 最后一条数据可能会不完整。当主机启动后，Redis 在 AOF 文件不完整的情况下是否可以启动，取决于属性 aof-load-truncated 的设置。其值为： 

* yes：AOF 文件最后不完整的数据直接从 AOF 文件中截断删除，不影响 Redis 的启动。 
* no：AOF 文件最后不完整的数据不可以被截断删除，Redis 无法启动

**（5）aof-timestamp-enabled**

该属性设置为 yes 则会开启在 AOF 文件中增加时间戳的显示功能，可方便按照时间对数 据进行恢复。但该方式可能会与 AOF 解析器不兼容，所以默认值为 no，不开启

### AOF 持久化过程

![](image\屏幕截图 2023-10-07 173922.png)

AOF 详细的持久化过程如下： 

1. Redis 接收到的写操作命令并不是直接追加到磁盘的 AOF 文件的，而是将每一条写命令 按照 redis 通讯协议格式暂时添加到 AOF 缓冲区 aof_buf。
2.  根据设置的数据同步策略，当同步条件满足时(**例如如果设置了`aof-rewrite-incremental-fsync`配置，当缓存达到4MB时**)，再将缓冲区中的数据一次性写入磁盘的 AOF 文件，以减少磁盘 IO 次数，提高性能。 
3. 当磁盘的 AOF 文件大小达到了 rewrite 条件时（**例如在`auto-aof-rewrite-percentage`和`auto-aof-rewrite-min-size`文件变化百分比超过上一次rewrite的大小和超过文件大小阈值**），redis-server 主进程会 fork 出一个子进程 bgrewriteaof，由该子进程完成 rewrite 过程。 
4. 子进程 bgrewriteaof 首先对该磁盘 AOF 文件进行 rewrite 计算，将计算结果写入到一个 临时文件，全部写入完毕后，再 rename 该临时文件为磁盘文件的原名称，覆盖原文件。 
5. 如果在 rewrite 过程中又有写操作命令追加，那么这些数据会暂时写入 aof_rewrite_buf 缓冲区。等将全部 rewrite 计算结果写入临时文件后，会先将 aof_rewrite_buf 缓冲区中 的数据写入临时文件，然后再 rename 为磁盘文件的原名称，覆盖原文件

## RDB 与 AOF 对比

### RDB优势与不足

**优势：RDB文件较小，所以数据恢复较快**

**不足：数据安全性较差；写时复制会降低性能；RDB文件可读性较差**

### AOF 优势与不足

**优势：数据安全性高（在追加aof时是阻塞的）；AOF文件的可读性强**

**不足：AOF文件较大；写操作会影响性能（写操作过多时会增加磁盘的IO操作，阻塞的）；数据恢复较慢**
