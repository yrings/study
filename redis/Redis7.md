# Redis7

## 第一章 Redis概述

### 1.1 Redis简介

> Redis，**Remote Dictionary Server**，远程字典服务，由意大利人 Salvatore  Sanfilippo（又名 Antirez）开发，是一个使用 ANSI **C 语言编写**、支持网络、 **可基于内存亦可持久化的日志型**、**NoSQL 开源内存数据库**，其提供多种语 言的 API。
>
> 
>
> Redis 之所以称之为字典服务，是因为 Redis 是一个 key-value 存储系统。支持存储的 value 类型很多，包括 String(字符串)、List(链表)、Set(集合)、Zset(sorted set --有序集合)和 Hash（哈 希类型）等。

#### 1.1.1 NoSQL

> NoSQL（“non-relational”， “Not Only SQL”），泛指非关系型的数据库。随着互联网 web2.0 网站的兴起，传统的关系数据库在处理 web2.0 网站，特别是超大规模和高并发的 SNS(社交) 类型 的 web2.0 纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据 库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数 据集合多重数据种类带来的挑战，特别是大数据应用难题。

有四大类：

1. **键值存储数据库**

   就像Map一样的key-value对，典型代表就是Redis。

2. **列存储数据库**

   关系型数据库是典型的行存储数据库。其的问题是按行存储的数据在物理层面占用的是连续的存储空键，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储。典型代表是HBase。

3. **文档型数据库**

   其是 NoSQL 与关系型数据的结合，最像关系型数据库的 NoSQL。典型代表是 MongoDB。

4. **图形（Graph）数据库**

​		用于存放一个节点关系的数据库，例如描述不同人间的关系。典型代表是 Neo4J。

### 1.2 Redis的用途

> Redis 在生产中使用最多的场景就是做数据缓存。即客户端从 DBMS 中查询出的数据首 先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不 仅减小了 RT(响应时长)，而且降低了 DBMS 的压力。

![](image\屏幕截图 2023-09-11 201634.png)

但是如果进行了写操作，就会导致后续的读操作数据不一致问题的出现，所以要如何解决呢？

> 将缓存数据进行分类
>
> 一是**实时同步缓存数据**，要求缓存**必须与DBMS中的数据保持一致**，只要DB发生改变，缓存中的数据就会消失。
>
> 二是**阶段性同步缓存数据**，允许缓存中的数据允许在一段时间内与DBMS中的数据不完全一致。而这个一段时间就是这个缓存数据的**过期时间**。

运维中有个名词叫做**warmup（预热）**，即在服务器启动时，在开始的一段时间里，不提供服务，其中一个最重要的作用就要把数据库中的一些重要的数据写入到缓存中。



### 1.3 Redis 特性

> 能够做缓存的技术、中间件很多，例如，MyBatis 自带的二级缓存、Memched 等。只所 以在生产中做缓存的产品几乎无一例外的会选择 Redis，是因为它有很多其它产品所不具备 的特性

* 性能极高：Redis 读的速度可以达到 11w 次/s，写的速度可以达到 8w 次/s。只所以具有 这么高的性能，因为以下几点原因：（1）Redis 的所有操作都是在内存中发生的。（2） Redis 是用 C 语言开发的。（3）Redis 源码非常精细（集性能与优雅于一身）。 

* 简单稳定：Redis 源码很少。早期版本只有 2w 行左右。从 3.0 版本开始，增加了集群功 能，代码变为了 5w 行左右。 

* 持久化：Redis 内存中的数据可以进行持久化，其有两种方式：分别是**RDB(Redis DataBase)和AOF(Append Only File)**。 

*  高可用集群：Redis 提供了高可用的主从集群功能，可以确保系统的安全性。 

* 丰富的数据类型：Redis 是一个 key-value 存储系统。支持存储的 value 类型很多，包括 String(字符串)、List(链表)、Set(集合)、Zset(sorted set --有序集合)和 Hash（哈希类型） 等，还有 BitMap、HyperLogLog、Geospatial 类型。 

  * BitMap：一般用于大数据量的二值性统计。

  *  HyperLogLog：其是 Hyperlog Log，用于对数据量超级庞大的日志做去重统计。
  *  Geospatial：地理空间，其主要用于地理位置相关的计算。

* 强大的功能：Redis 提供了数据过期功能、发布/订阅功能、简单事务功能，还支持 Lua 脚本扩展功能。 

* 客户端语言广泛：Redis提供了简单的 TCP 通信协议，编程语言可以方便地的接入 Redis。 所以，有很多的开源社区、大公司等开发出了很多语言的 Redis 客户端。 

* 支持 **ACL **权限控制：之前的权限控制非常笨拙。从 Redis6 开始引入了 ACL 模块，可以 为不同用户定制不同的用户权限。

  ```txt
  ACL，Access Control List，访问控制列表，是一种细粒度的权限管理策略，可以针对任意 用户与组进行权限控制。目前大多数 Unix 系统与 Linux 2.6 版本已经支持 ACL 了。 Zookeeper 早已支持 ACL 了。 Unix 与 Linux 系统默认使用是 UGO（User、Group、Other）权限控制策略，其是一种粗 粒度的权限管理策略。
  ```

*  支持多线程 IO 模型：Redis 之前版本采用的是单线程模型，从 6.0 版本开始支持了多线 程模型。

### 1.4 Redis 的IO模型

> Redis 客户端提交的各种请求是如何最终被 Redis 处理的？Redis 处理客户端请求所采用 的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的。

#### 1.4.1 单线程模型

> 对于 Redis 3.0 及其以前版本，Redis 的 IO 模型采用的是纯粹的单线程模型。即所有客户 端的请求全部由一个线程处理

![](image\屏幕截图 2023-09-11 204713.png)

Redis的单线程模型采用了多路复用技术（异步IO，本质上是同步IO）。

> I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间

对于多路复用器的多路选择算法常见的有三种：select 模型、poll 模型、epoll 模型。

|              | select                                                       | poll                                                         | epoll                                             |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------- |
| 性能         | 随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差 | 随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差 | 随着连接数的增加，性能基本没有变化                |
| 连接数       | 一般1024                                                     | 无限制                                                       | 无限制                                            |
| 内存拷贝     | 每次调用select拷贝                                           | 每次调用poll拷贝                                             | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 数据结构     | bitmap                                                       | 数组                                                         | 红黑树                                            |
| 内在处理机制 | 线性轮询                                                     | 线性轮询                                                     | FD挂在红黑树，通过事件回调callback                |
| 时间复杂度   | O(n)                                                         | O(n)                                                         | O(1)                                              |

```txt
select 模型：select函数监视的文件描述符有三类，readfds，writefds，exceptfds。调用后函数会阻塞，直到有描述符就绪（有数据读、写、或者有except），或者超时（timeout指定时间，如果立即返回设置null），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。（监视的文件描述符的数量存在最大限制，根据系统内核linux是1024）

poll 模型的选择算法：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的。
epoll 模型的选择算法：采用的是回调方式。根据就绪事件发生后的处理方式的不同，
又可分为 LT 模型与 ET 模型。
```

每个客户端若要向 Redis 提交请求，都需要与 Redis 建立一个 socket 连接，并向事件分 发器注册一个事件。一旦该事件发生就表明该连接已经就绪。

而一旦连接就绪，事件分发器 就会感知到，然后获取客户端通过该连接发送的请求，并将由该事件分发器所绑定的这个唯 一的线程来处理。如果该线程还在处理多个任务，则将该任务写入到任务队列等待线程处理。 

之所以称为事件分发器，是因为它会根据不同的就绪事件，将任务交由不同的事件处理 器去处理。

#### 1.4.2 混合线程模型

> 从 Redis 4.0 版本开始，Redis 中就开始加入了多线程元素。处理客户端请求的仍是单线 程模型，但对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理。 例如，持久化、对 AOF 的 rewrite、对失效连接的清理等。

#### 1.4.3 多线程模型

> **多线程 IO 模型中的“多线程”仅用于接受、解析客户端的请求，然后将解析出的请求 写入到任务队列。而对具体任务（命令）的处理，仍是由主线程处理。**这样做使得用户无需 考虑线程安全问题，无需考虑事务控制，无需考虑像 LPUSH/LPOP 等命令的执行顺序问题。

![](image\屏幕截图 2023-09-11 204739.png)

#### 1.4.4 优缺点总结

>  内存的响应时长是（RT）100ns
>
> Redis理论上每秒处理的读写的请求数量应该可以打到 1s/100ns = 10^7 = 1kw
>
> 实际上，Redis可以处理8w~11w的读写请求。

* 单线程模型

  优点：可维护性高，性能高。不存在并发读写情况，所以也就不存在执行顺序的不确定 性，不存在线程切换开销，不存在死锁问题，不存在为了数据安全而进行的加锁/解锁 开销。 

  缺点：性能会受到影响，且由于单线程只能使用一个处理器，所以会形成处理器浪费。

* 多线程模型

  结合了多线程与单线程的优点。但是真正的任务处理还是单线程，其性能还是有提升的空间。

## 第二章 Redis的安装与使用

### 2.1 CentOS7的配置

* 配置分区

  选择标准分区，然后配置分区。

  创建三个分区：/boot区(300MB)、swap交换分区(512MB)、根分区/

* 配置静态IP

  在VMware的“编辑”中选择“虚拟网络编辑器”，取消勾选DHCP服务将IP分配给虚拟机

  **启动虚拟机，进入网络配置文件目录：cd /etc/sysconfig/network-scripts/，然后编辑ifcfg-ens33文件：vi ifcfg-ens33。按shift+i进入insert编辑模式**

  - BOOTPROTO=static 启用静态IP地址
  - ONBOOT=yes   开启自动启用网络连接

    添加以下内容：

  - IPADDR=192.168.30.100   设置IP地址
  - NETMASK=255.255.255.0  子网掩码
  - GATEWAY=192.168.30.2  设置网关

### 2.2 用Xshell连接系统

我们在电脑上打开：控制面板—>网络和 Internet—>网络和共享中心—>更改适配器—>找到MVnet8—>右键属性—>双击Internet协议版本4。

![](image\屏幕截图 2023-09-11 225854.png)

### 2.3 安装Redis

* 将redis-7.0.3.tar.gz 上传到linux的/opt/tools目录中

* 解压Redis

  ```txt
  tar -zxvf redis-7.0.3.tar.gz -C /opt/apps/
  ```

* 修改文件名

  ```txt
  mv redis-7.0.3.tar.gz/ redis
  ```

* 编译

  编译的过程是根据Makefile文件进行的，进入到解压后的文件目录，执行`make`指令进行编译。

  编译成功后执行，`make install`进行安装

会安装三个文件，`redis-server redis-benchmark(性能测试工具) redis-cli `

* 查看文件目录和执行文件目录`/usr/local/bin`

![](image\屏幕截图 2023-09-11 232254.png)

redis-check-aof和redis-check-rdb是转换成持久层数据工具，都是redis-server的子应用

用`echo $PATH`查看系统环境配置可以看见，已经指定配置好reids执行文件的路径

### 2.4 Redis启动与停止

用`redis-server`运行，端口号6379（MEZD）愚蠢

![image-20230911233927085](C:\Users\13218\AppData\Roaming\Typora\typora-user-images\image-20230911233927085.png)

`ps aux | grep 程序名` 查看运行的某个程序

这种方式会占用命令行，所以一般用后台启动`nohup redis-server &`

这种方式启动会调用redis默认的配置来启动，这种启动方式会在启动目录生成一个`nohup.out `日志文件

`rpm -qa |grep 程序名`查看是否安装某个程序

* 用守护线程方式运行，打开`redis.conf`文件，`/daemonize`查找到daemonize选项，修改成yes。

  用命令`redis-server /opt/apps/redis/redis.conf` 来指定配置文件启动。不指定会使用默认的配置。

  用`redis-cli shutdown`来关闭redis。

### 2.5 Redis的连接配置

到redis.conf文件中配置

#### 绑定客户端ip

找到`bind 127.0.0.1 -::1`一行，将该行注释掉，即表示可以连接所有ip地址。

#### 关闭保护模式

找到`protected-mode yes`将其改成no，允许别的主机访问。

#### 设置访问密码

找到`requirepass foobared `默认是被注释掉的，不需要密码，将foobared改成密码即可

> 不用密码启动也能访问redis，但不能操作

登陆有两种方式，在启动客户端时就用密码`redis-cli -a 111`

启动时没用密码，访问后再用密码登陆`auth 111`

终止连接时`shutdown`，但是要登陆才行，然后`quit`退出

#### 命令控制

> 后面要学习两个非常危险的命令：flushal 与 flushdb。它们都是用于直接删除整个 Redis 数据库的。若让用户可以随便使用它们，可能会危及数据安全。Redis 可以通过修改配置文 件来禁止使用这些命令，或重命名这些命令。以下配置，禁用了 flushall 与 flushdb 命令。

找到`rename-command`相关的区块，然后添加上如下命令即可：

`rename-command flushall ""`直接禁用flushall

`rename-command flushall "myfa"`改名

### 2.6 redis客户端

#### 命令行客户端

客户端的连接，

`redis-cli -h <ip地址> -p <端口号> -a <密码>`

如果在本机连接ip地址可省略，如果端口号是6379，端口号也可省略

#### 图形化界面

> Redis Desktop Manage 0.8.8.384

在linux下的防火墙中开放6379端口

```bash
[root@localhost bin]# firewall-cmd --zone=public --add-port=6379/tcp --permanent
```

重启防火墙

```bash
[root@localhost bin]# systemctl restart firewalld
```

#### java 代码客户端

略

### 2.7 ☆Redis 配置文件详解

> Redis的核心配置文件redis.conf，默认包含有2000多行。这些内容被分为好几个部分。

![](image\屏幕截图 2023-09-12 113746.png)

这部分包含三个意思：

* 如果要启动redis，需要指出配置文件的路径
* 说明当前配置文件中可以使用的容量单位及含义
* 这些容量单位没有大小写之分

#### includes

![](image\屏幕截图 2023-09-12 114124.png)

指定要在当前配置文件中包含的配置文件。这样做的目的主要是便于配置信息管理：可以将不同场景的配置都进行单独定义，然后在当前核心配置文件中根据不同场景选择包含进 不同的配置文件

**如果你要使用自己的配置文件来管理配置信息，要在最后一行加上配置信息的路径，即如图格式。之后会覆盖默认的配置信息**

#### modules

![](image\屏幕截图 2023-09-12 195233.png)

Redis配置文件中可以通过加载不同的第三方模块来增强、扩展Redis的功能。

配置方式与includes类似。

#### network

> Network配置模块是比较重要的部分，主要进行网络相关的配置。

* bind

  指定可以访问当前Redis服务的客户端IP，注释掉即可确保其它客户端可以连接Redis。

* protected-mode

  默认保护模式是开启的。只允许本机的客户端访问。

* port

  Redis监听的连接端口号，默认6379

* **☆tcp-backlog**

  > tcp-backlog是一个TCP连接的队列，其主要用于解决高并发场景下客户端**慢连接**问题。这里设置的值就是这个队列的长度。该队列与TCP连接的三次握手有关。不同Linux内核。backlog队列中存放的元素类型是不同的。

  * Linux内核2.2版本之前，该队列中存放的是已完成第一次握手的所有连接，也包括已完成三次握手的。他们之间通过连接状态不同来区分的，未完成三次握手的是SYN_RECEIVED，一完成的是ESTABLISHED。只有ESTABLISHED状态的连接才会被Redis处理。
  * Linux内核2.2版本之后，该队列就只存放已完成三次握手的连接即ESTABLISHED队列，未完成三次握手的连接就会放到SYN_RECEIVED队列中。

  > 这里的参数是来设置队列长度的，但是TCP中的backlog队列的长度在Linux中还由内核参数somaxconn来决定。取他们两的最小值。
  >
  > somaxconn也是在Linux中决定TCP队列的长度

####  Linux内核中somaxconn的值

查看linux内核版本：

```
uname -a

cat /proc/version
```

查看somaxconn的值：

```
cat /proc/sys/net/core/somaxconn
```

要修改它的值要到`/etc/sysctl.conf`文件中，在文件最后添加如下内容

`net.core.somaxconn=2048`

重启虚拟机生效，也可以用命令`sysctl -p`来使其生效。

* timeout

  空闲超时。当客户端与Redis间的空闲时间超过该时长后，自动断开连接。单位秒。默认为0，永远不会断开。

* tcp-keepalive 

  该配置主要用于设置Redis检测与其连接的所有客户端的存活性时间间隔，单位秒，即多少秒检测一次。一般是在空闲时间超时timeout设置为0时进行配置。要两次检测都不存活才会关闭连接。

  > 其它的方法比较泛用的是心跳，即客户端告诉服务端我还活着。

#### general

* daemonize

  该配置可以控制Redis启动是否采用守护进程方式，即是否是后台启动。yes是采用。

* pidfile

  该配置用于指定Redis运行时pid写入与保存的文件，无论Redis是否采用守护进程方式启动，pid都会写入到该配置的文件。

  注意，如果没有配置 pid 文件，不同的启动方式，pid 文件的产生效果是不同的： 

   采用守护进程方式启动（后台启动，daemonize 为 yes）：pid 文件为/var/run/redis.pid。 

   采用前台启动（daemonize 为 no）：不生产 pid 文件

* loglevel

  配置日志的级别。Redis中共有四个级别，由低到高依次是：

  * debug：可以获取到很多的信息，一般在开发和测试时使用。 

  * verbose：可以获取到很多不太有用的信息，但不像 debug 级别那么多。

  * notice：可以获取到在生产中想获取到的适当多的信息，默认级别。 

  * warning：只记录非常重要/关键的信息。

* logfile

  指定日志文件。如果设置为空串，则强制将日志记录到标准输出设备（显示器）。如果 使用的是守护进程启动方式，设置为空串，则意味着会将日志发送到设备/dev/null（空设备）

* database

  设置数据库的数量。默认数据库是0号数据库。可以使用select<dbid>在每个连接的基础上选择一个不同的数据库，其中dbid是介于0和‘databases - 1’之间的数字。

#### security

> 用户设置ALT权限、Redis访问密码相关配置。该模块中最常用的就是requirepass属性。

* requirepass

  设置客户端访问密码。注释掉后则没有密码

#### client

> 该模块用于设置与客户端相关的属性，其中仅包含一个属性 maxclients。 
>
> maxclients 用于设置 Redis 可并发处理的客户端连接数量，默认值为 10000。如果达到了 该最大连接数，则会拒绝再来的新连接，并返回一个异常信息：已达到最大连接数。 
>
> 注意，该值不能超过 Linux 系统支持的可打开的文件描述符最大数量阈值。
>
> 查看该阈值的方式如下：
>
> `ulimit -n`
>
>  可以通过修改`/etc/security/limits.conf`文件
>
> 对集群有影响（后面涉及到的）

#### memory management

> 该配置可以控制最大可用内存及相关内容移除问题

* maxmemory

  将内存使用限制设置为指定的字节数。当达到内存限制时，Redis将根据选择的逐出策略maxmemory-policy 尝试删除符号条件的key

  如果不能移除，则会给写操作命令返回error，对读没影响。

* maxmemory-policy

  * volatile-lru：使用近似 LRU 算法移除，仅适用于设置了过期时间的 key。 

  * allkeys-lru：使用近似 LRU 算法移除，可适用于所有类型的 key。 

  * volatile-lfu：使用近似 LFU 算法移除，仅适用于设置了过期时间的 key。 

  * allkeys-lfu：使用近似 LFU 算法移除，可适用于所有类型的 key。 

  * volatile-random：随机移除一个 key，仅适用于设置了过期时间的 key。 

  * allkeys-random：随机移除一个 key，可适用于所有类型的 key。 

  * volatile-ttl：移除距离过期时间最近的 key。
  * noeviction：不移除任何内容，只是在写操作时返回一个错误，默认值。

  > LRU：least-recently used也就是每次淘汰那些最久没被使用的数据
  >
  > LFU ：Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。

* maxmemory-samples

  该属性用于指定挑选的key的样本数量，即从样本key中按策略挑选一个。样本的选择采用的是LRU算法，其不能修改，但从样本中再选择要移除的key，则采用的是maxmemory-policy指定的策略

* maxmemory-eviction-tenacity

  设置移除容忍度。数值越小表示容忍度越低，需要移除的数据移除延迟越小；数值越大 表示容忍度越高，需要移除的数据移除延迟越大

#### threaded I/O

> 该模块用于配置Redis对多线程IO模型的支持

* io-threads

  该属性用于指定要启动多线程IO模型时，要使用的线程数量。

  启用多线程IO模型，最好要有四个核的CPU，然后最好要剩下一个CPU

  查看当前系统中包含的CPU数量。

  ```
  lscpu
  ```

  CPU(S)的值

* io-threads-do-reads

  该属性用于启动多线程IO模型中多线程处理读请求的能力。