# MySQL-interview

## 01-Mysql如何实现索引机制？

MySQL 中索引分三类：B+树索引、Hash索引、全文索引

### 02-B+树详解

> 为了实现动态多层索引，通常采用B-或B+树。

* **B树的引入？**

  对于红黑树来说，虽然是平衡的、有序的查找树，但是当数据量较大时，就会导致树的深度很大；树的深度越大也就意味着IO次数越多，影响读取效率。

  这时候也就用到了B树。

* **B树的概念**

  满足以下条件的m叉树就是B树：

  1. 树的每个节点至多有m个孩子节点[即至多有m-1个关键字（关键字用来当做类似索引，但是B树中也会存储数据）]。

  2. 每个节点的结构为

     ![](C:\Users\13218\Desktop\study\MySQL\image\屏幕截图 2023-12-25 195258.png)

     n：代表关键字的个数

     p：代表指针

     k：代表索引

  3. 除根结点外，其它结点至少有 `m/2`个孩子节点

  4. 如果根结点不是叶子节点，则根结点至少有两个孩子结点

  5. 所有叶子结点都在同一层

* **B+树的引入**

  > 概念引入：**磁盘预读**
  >
  > 内存和磁盘发生数据交互时，一般情况下有一个最小的逻辑单元，称为页
  >
  > 页的大小和操作系统有关，一般为4k或8k，我们在数据交互时，可以**取页的整数倍来进行读取**

  假设我们一次读取根结点的数据为16k，如果是B树，我们在非叶子结点上也会存储数据，这就导致我们能够存储的指针减少，导致数据总存储量下降。

  所以这时，就引入了B+树，它和B树的区别在于，它的非叶子结点是不会存储数据的，只有叶子结点来存储数据

## 03-InnoDB索引与MyISAM索引实现的区别是什么

> 一般的索引会根据列的类型，分为主键索引和辅助索引

**MyISAM索引实现：**

* **主键索引**

  MyISAM引擎使用B+树作为索引结果，叶节点的data域存放的是数据记录的物理地址。

  ![](C:\Users\13218\Desktop\study\MySQL\image\屏幕截图 2023-12-24 185509.png)

* **辅助索引**

  在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

  同样也是一颗B+Tree，data域保存数据记录的地址。因此，**MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。**

  MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

**InnoDB索引实现**

* **主键索引**

  同样是B+树，实现方式却完全不同。InnoDB表数据文件本身就是一个索引结构，树的叶节点data域保存了完整的数据记录，这种索引叫做**聚集索引**。

  ![](C:\Users\13218\Desktop\study\MySQL\image\屏幕截图 2023-12-24 185751.png)

  因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键(MyISAM可以没有)，如果没有显式指定，则mysql会自动选择一个可以唯一标识数据记录的列作为主键。如果不存在这种列，则mysql自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。

* **辅助索引**

  InnoDB的所有辅助索引都引用主键作为data域。

  ![](C:\Users\13218\Desktop\study\MySQL\image\屏幕截图 2023-12-24 185957.png)

  因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引也会包含主键列，所以如果主键定义的比较大，其他索引也将很大。InnoDB 不会压缩索引。

  **聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。**

  不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

  

**InnoDB索引和MyISAM索引的区别**

1 存储结构（主索引／辅助索引）

InnoDB的数据文件本身就是主索引文件。而MyISAM的主索引和数据是分开的。

InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。

innoDB是聚簇索引，数据挂在逐渐索引之下。

2 锁

MyISAM使用的是表锁  InnoDB使用行锁

3 事务

MyISAM没有事务支持和MVCC

InnoDB支持事务和MVCC

4 主键

MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址

InnoDB如果没有设定主键或非空唯一索引，就会自动生成一个6字节的主键，数据是主索引的一部分，附加索引保存的是主索引的值

5 外键

MyISAM不支持，InnoDB支持

### 04-什么是MVCC机制？

> MVCC,即multi-vertion concurrency control （多版本并发控制）。
>
> 它是为了解决脏读和不可重复读等事务之间读写问题而诞生的。他的性能比锁要好。
>
> **MVCC机制是基于Undo Log （版本链）和Read View（读视图）来完成的。**



* **Undo Log 版本链**

  对于Undo Log中是修改记录的行记录：

  ![](C:\Users\13218\Desktop\study\MySQL\image\屏幕截图 2023-12-25 200957.png)

  当有事务对这一条数据发生修改和删除操作时，就会让最新的事务roll_pointer指向版本链头部。

* **Read View**

  当事务`select` 查询数据时，就会创建一个read view，里面会包括版本链信息的统计值，以便后面判断该读取哪一个版本链数据。

  版本链信息包括：

  1. 当前活跃的事务（未提交事务）的id：`m_ids`
  2. 当前活跃事务集合中最小的事务id：`min_trx_id`
  3. 接下来将被分配的事务的id（版本链头事务id+1）：`max_trx_id`
  4. 创建这个Read View 的事务id：`creator_trx_id`

  **然后根据四步查找规则从集合的版本链头查找符合的版本：**

  1. 判断该版本是否为当前事务创建。若不是，即遍历到的事务与`creator_trx_id`不等，则进入下一步。如果是，则可以访问。
  2. 判断该版本事务id是否小于`min_trx_id`。如果小于，这说明这个事务已经提交，可以访问；否则进入第三步
  3. 判断该版本事务id是否大于`max_trx_id`。如果大于说明这个事务在当前事务创建之后才创建，肯定不能访问，直接遍历下一个版本；如果小于，则进入第四步。
  4. 判断该版本事务id在不在活跃事务集合中。如果不在说明已提交，可以访问；否则不能方法，遍历下一个事务版本。



## 05-MySQL的写入存储机制

* **写入机制**

  当发生数据的写操作时，InonDB会先把数据写到内存中去，即一个空间 `Buffer Pool`，然后会在特定的时机，会启动IO线程来把写入信息更新到磁盘里面（这个过程底层会跳过计算机的缓存容器），然后为了支持回滚也会更新Undo Log文件。

  但是如果发生宕机，就会导致数据丢失问题。为了解决这个问题就在内存中加入了一个`Redo Log Buffer`,会把更新写入信息先放到这里。每次在事务提交前，都会把更新信息写入磁盘里的`Redo Log`文件中。

* **存储机制**

  MySQL最小的存储单元是页（16K），由于数据库的原因，一般查询都会查询一连串的数据，一个页的数据信息的地址是可以保证连续，但是如果数据量很大的话，就会发生跳页情况，如果跳跃间距过大，就会很消耗读取性能。

  这时就引入了区（1M），让区的数据地址都大概率在附近地址；并且能够将区加载到内存中缓存，减少对磁盘的访问。

  为了不浪费空间，新建的表的页会放到**碎片区**的地方，当数据量增加时就会创建新的区，之后每次申请空间都会一个区一个区的申请。



















